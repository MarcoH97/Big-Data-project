lowest_cumulative_return <- Inf
highest_cumulative_return <- -Inf
lowest_cumulative_series <- NULL
highest_cumulative_series <- NULL
exclude <- FALSE
df_series_to_plot <- data.frame()
# Loop over all possible starting times for the specified time horizon
for (i in 1:(nrow(df_return_series) - time_horizon_days + 1)) {
# Compute cumulative returns for the current time period
cum_returns_time_period <- cumprod(1 + df_return_series[i:(i + time_horizon_days - 1), col])
# Compute series to plot for every year (for visualization purposes)
if(i %% 252 == 0) {
df <- data.frame(Year = 1:length(cum_returns_time_period)/252,
CumReturns = cum_returns_time_period,
Series_ID = paste("Series", i)) # Identifier for each series
# Combine this df with the df for all series
df_series_to_plot <- rbind(df_series_to_plot, df)
}
# Check if the minimum cumulative return is below the threshold and set the flag to exclude the strategy if so
if (any(cum_returns_time_period < minimum_allowable_percentage)) {
exclude <- TRUE
################# break # We deleted this break from the code, because we are still interested in all the graphs
}
# Keep track of the lowest cumulative return for the current strategy
if (cum_returns_time_period[length(cum_returns_time_period)] < lowest_cumulative_return) {
lowest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
lowest_cumulative_series <- cum_returns_time_period
}
# Keep track of the highest cumulative return for the current strategy
if (cum_returns_time_period[length(cum_returns_time_period)] > highest_cumulative_return) {
highest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
highest_cumulative_series <- cum_returns_time_period
}
}
# Generate plot displaying all series of cumulative returns for the current investment strategy.
# Each series represents a different start time within the time horizon.
plot_different_periods_within_strategy <-
ggplot(df_series_to_plot, aes(x=Year, y=CumReturns, color=Series_ID)) +
geom_line() +
geom_hline(yintercept = minimum_allowable_percentage, linetype = "dashed", color = "red") +
labs(x = "Years invested", y = "Cumulative Return", title = paste("Cumulative returns for different starting dates (subset of actual analysis), for", col)) +
theme(legend.position="none") +
scale_y_continuous(limits = c(0, NA))
# The resulting plot is added to the list `plot_list_different_periods_within_strategies` for later use.
plot_list_different_periods_within_strategies[[col]] <- plot_different_periods_within_strategy
# If the strategy is marked for exclusion, add to df_refused, else add to df_above_threshold
if (exclude == TRUE) {
df_refused <- rbind(df_refused, data.frame(Strategy = col, LowestCumulativeReturn = lowest_cumulative_return, HighestCumulativeReturn = highest_cumulative_return))
lowest_series[[col]] <- lowest_cumulative_series
highest_series[[col]] <- highest_cumulative_series
} else {
df_above_threshold <- rbind(df_above_threshold, data.frame(Strategy = col, LowestCumulativeReturn = lowest_cumulative_return, HighestCumulativeReturn = highest_cumulative_return))
lowest_series[[col]] <- lowest_cumulative_series
highest_series[[col]] <- highest_cumulative_series
}
}
# Select the optimal strategy as the one with the highest minimum cumulative return that didn't fall below the threshold
optimal_strategy <- df_above_threshold[which.max(df_above_threshold$LowestCumulativeReturn), "Strategy"]
# Prepare data for plotting lowest cumulative returns for each strategy, categorizing them as above_threshold or excluded
plot_lowest_cum_returns_data <- do.call(rbind, lapply(names(lowest_series), function(name) {
group <- ifelse(name %in% df_above_threshold$Strategy, "above_threshold", "excluded")
data.frame(Year = 1:length(lowest_series[[name]])/252, Return = lowest_series[[name]], Strategy = name, Group = group, stringsAsFactors = FALSE)
}))
# Assign colors for the plot: 'darkgreen' for strategies above threshold and 'gray90' for excluded strategies
color_mapping <- setNames(ifelse(unique(plot_lowest_cum_returns_data$Strategy) %in% df_above_threshold$Strategy, "darkgreen", "gray90"), unique(plot_lowest_cum_returns_data$Strategy))
# Rearrange the order of the 'Group' factor to ensure 'above_threshold' group is plotted last (and therefore on top)
plot_lowest_cum_returns_data$Group <- factor(plot_lowest_cum_returns_data$Group, levels = c("excluded", "above_threshold"))
# Generate a plot illustrating the evolution of the lowest cumulative return series for each investment strategy
# Strategies are color-coded based on group - 'above_threshold' and 'excluded'
plot_lowest_cum_returns <-
ggplot(plot_lowest_cum_returns_data, aes(x = Year, y = Return, color = Strategy, group = Strategy)) +
geom_line(data = subset(plot_lowest_cum_returns_data, Group == "excluded")) +
geom_line(data = subset(plot_lowest_cum_returns_data, Group == "above_threshold")) +
scale_color_manual(values = color_mapping) +
geom_hline(yintercept = minimum_allowable_percentage, linetype = "dashed", color = "red") +
labs(title = "Lowest cumulative return series, for each candidate investment strategy", x = "Years invested", y = "Cumulative return") +
theme_minimal() +
theme(legend.position="none") +
scale_y_continuous(limits = c(0, NA))
# Extract plot data for the optimal strategy
plot_optimal_strategy_data <- ggplot_build(plot_list_different_periods_within_strategies[[optimal_strategy]])$data[[1]]
# Generate a plot that visualizes worst-case, best-case, and other return series for the optimal strategy
plot_optimal_strategy <-
ggplot() +
geom_line(data = plot_optimal_strategy_data, aes(x = x, y = y, color = colour), alpha = 0.2) +
geom_line(data = data.frame(Year = 1:length(lowest_series[[optimal_strategy]])/252, Return = lowest_series[[optimal_strategy]]), aes(x = Year, y = Return), color = "red") +
geom_line(data = data.frame(Year = 1:length(highest_series[[optimal_strategy]])/252, Return = highest_series[[optimal_strategy]]), aes(x = Year, y = Return), color = "green") +
geom_hline(yintercept = minimum_allowable_percentage, linetype = "dashed", color = "red") +
labs(title = paste("Worst-case, best-case and other historic return series for your optimal strategy:", optimal_strategy), x = "Years invested", y = "Cumulative return") +
theme_minimal() +
theme(legend.position="none") +
scale_y_continuous(limits = c(0, NA))
# Compute and print the total execution time of the function
total_function_end <- Sys.time()
total_function_time <- as.numeric(total_function_end - total_function_start, units = "secs")
print(paste("Execution time for TOTAL FUNCTION: ", total_function_time, "seconds"))
# Return the plots, optimal strategy, and data frames of results
return(list(plot_lowest_cum_returns, optimal_strategy, plot_optimal_strategy, df_above_threshold, df_refused, plot_list_different_periods_within_strategies, total_function_time))
}
# Load functions file
source("BDA_BDBD_functions - Luca.R")
library(gridExtra)
gc()
#' @param minimum_allowable_percentage The minimum allowable cumulative return percentage below which a strategy should be excluded.
#'
#' @return A list containing the following elements:
#' - plot_lowest_cum_returns: a ggplot object illustrating the evolution of the lowest cumulative return series for each investment strategy.
#' - optimal_strategy: the optimal investment strategy identified.
#' - plot_optimal_strategy: a ggplot object that visualizes worst-case, best-case, and other return series for the optimal strategy.
#' - df_above_threshold: a data frame containing strategies that have not been excluded, their lowest and highest cumulative returns.
#' - df_refused: a data frame containing excluded strategies, their lowest and highest cumulative returns.
#' - plot_list_different_periods_within_strategies: a list of ggplot objects, each representing cumulative returns for different starting dates for a particular strategy.
#'
determine_optimal_strategy_v1 <- function(df_return_series, time_horizon_years, minimum_allowable_percentage) {
# Start timer for performance tracking
total_function_start <- Sys.time()
# Initialize constants and variables
days_per_year <- 252
time_horizon_days <- time_horizon_years * days_per_year
# Initialize data frames to store results
df_above_threshold <- data.frame(Strategy = character(), LowestCumulativeReturn = numeric())
df_refused <- data.frame(Strategy = character(), LowestCumulativeReturn = numeric())
# Initialize lists to store the lowest and highest return series for each strategy
lowest_series <- list()
highest_series <- list()
# Initialize a list to store return series of the optimal strategy
optimal_strategy_series <- list()
# Initialize a list to store ggplot objects for each strategy.
# Each ggplot object represents cumulative returns for different starting dates for a particular strategy.
plot_list_different_periods_within_strategies <- list()
# Main loop over each strategy
for (col in names(df_return_series)[-1]) {
# Initialization of variables for current strategy
lowest_cumulative_return <- Inf
highest_cumulative_return <- -Inf
lowest_cumulative_series <- NULL
highest_cumulative_series <- NULL
exclude <- FALSE
df_series_to_plot <- data.frame()
# Loop over all possible starting times for the specified time horizon
for (i in 1:(nrow(df_return_series) - time_horizon_days + 1)) {
# Compute cumulative returns for the current time period
cum_returns_time_period <- cumprod(1 + df_return_series[i:(i + time_horizon_days - 1), col])
# Compute series to plot for every year (for visualization purposes)
if(i %% 252 == 0) {
df <- data.frame(Year = 1:length(cum_returns_time_period)/252,
CumReturns = cum_returns_time_period,
Series_ID = paste("Series", i)) # Identifier for each series
# Combine this df with the df for all series
df_series_to_plot <- rbind(df_series_to_plot, df)
}
# Check if the minimum cumulative return is below the threshold and set the flag to exclude the strategy if so
if (any(cum_returns_time_period < minimum_allowable_percentage)) {
exclude <- TRUE
################# break # We deleted this break from the code, because we are still interested in all the graphs
}
# Keep track of the lowest cumulative return for the current strategy
if (cum_returns_time_period[length(cum_returns_time_period)] < lowest_cumulative_return) {
lowest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
lowest_cumulative_series <- cum_returns_time_period
}
# Keep track of the highest cumulative return for the current strategy
if (cum_returns_time_period[length(cum_returns_time_period)] > highest_cumulative_return) {
highest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
highest_cumulative_series <- cum_returns_time_period
}
}
# Generate plot displaying all series of cumulative returns for the current investment strategy.
# Each series represents a different start time within the time horizon.
plot_different_periods_within_strategy <-
ggplot(df_series_to_plot, aes(x=Year, y=CumReturns, color=Series_ID)) +
geom_line() +
geom_hline(yintercept = minimum_allowable_percentage, linetype = "dashed", color = "red") +
labs(x = "Years invested", y = "Cumulative Return", title = paste("Cumulative returns for different starting dates (subset of actual analysis), for", col)) +
theme(legend.position="none") +
scale_y_continuous(limits = c(0, NA))
# The resulting plot is added to the list `plot_list_different_periods_within_strategies` for later use.
plot_list_different_periods_within_strategies[[col]] <- plot_different_periods_within_strategy
# If the strategy is marked for exclusion, add to df_refused, else add to df_above_threshold
if (exclude == TRUE) {
df_refused <- rbind(df_refused, data.frame(Strategy = col, LowestCumulativeReturn = lowest_cumulative_return, HighestCumulativeReturn = highest_cumulative_return))
lowest_series[[col]] <- lowest_cumulative_series
highest_series[[col]] <- highest_cumulative_series
} else {
df_above_threshold <- rbind(df_above_threshold, data.frame(Strategy = col, LowestCumulativeReturn = lowest_cumulative_return, HighestCumulativeReturn = highest_cumulative_return))
lowest_series[[col]] <- lowest_cumulative_series
highest_series[[col]] <- highest_cumulative_series
}
}
# Select the optimal strategy as the one with the highest minimum cumulative return that didn't fall below the threshold
optimal_strategy <- df_above_threshold[which.max(df_above_threshold$LowestCumulativeReturn), "Strategy"]
# Prepare data for plotting lowest cumulative returns for each strategy, categorizing them as above_threshold or excluded
plot_lowest_cum_returns_data <- do.call(rbind, lapply(names(lowest_series), function(name) {
group <- ifelse(name %in% df_above_threshold$Strategy, "above_threshold", "excluded")
data.frame(Year = 1:length(lowest_series[[name]])/252, Return = lowest_series[[name]], Strategy = name, Group = group, stringsAsFactors = FALSE)
}))
# Assign colors for the plot: 'darkgreen' for strategies above threshold and 'gray90' for excluded strategies
color_mapping <- setNames(ifelse(unique(plot_lowest_cum_returns_data$Strategy) %in% df_above_threshold$Strategy, "darkgreen", "gray90"), unique(plot_lowest_cum_returns_data$Strategy))
# Rearrange the order of the 'Group' factor to ensure 'above_threshold' group is plotted last (and therefore on top)
plot_lowest_cum_returns_data$Group <- factor(plot_lowest_cum_returns_data$Group, levels = c("excluded", "above_threshold"))
# Generate a plot illustrating the evolution of the lowest cumulative return series for each investment strategy
# Strategies are color-coded based on group - 'above_threshold' and 'excluded'
plot_lowest_cum_returns <-
ggplot(plot_lowest_cum_returns_data, aes(x = Year, y = Return, color = Strategy, group = Strategy)) +
geom_line(data = subset(plot_lowest_cum_returns_data, Group == "excluded")) +
geom_line(data = subset(plot_lowest_cum_returns_data, Group == "above_threshold")) +
scale_color_manual(values = color_mapping) +
geom_hline(yintercept = minimum_allowable_percentage, linetype = "dashed", color = "red") +
labs(title = "Lowest cumulative return series, for each candidate investment strategy", x = "Years invested", y = "Cumulative return") +
theme_minimal() +
theme(legend.position="none") +
scale_y_continuous(limits = c(0, NA))
# Extract plot data for the optimal strategy
plot_optimal_strategy_data <- ggplot_build(plot_list_different_periods_within_strategies[[optimal_strategy]])$data[[1]]
# Generate a plot that visualizes worst-case, best-case, and other return series for the optimal strategy
plot_optimal_strategy <-
ggplot() +
geom_line(data = plot_optimal_strategy_data, aes(x = x, y = y, color = colour), alpha = 0.2) +
geom_line(data = data.frame(Year = 1:length(lowest_series[[optimal_strategy]])/252, Return = lowest_series[[optimal_strategy]]), aes(x = Year, y = Return), color = "red") +
geom_line(data = data.frame(Year = 1:length(highest_series[[optimal_strategy]])/252, Return = highest_series[[optimal_strategy]]), aes(x = Year, y = Return), color = "green") +
geom_hline(yintercept = minimum_allowable_percentage, linetype = "dashed", color = "red") +
labs(title = paste("Worst-case, best-case and other historic return series for your optimal strategy:", optimal_strategy), x = "Years invested", y = "Cumulative return") +
theme_minimal() +
theme(legend.position="none") +
scale_y_continuous(limits = c(0, NA))
# Compute and print the total execution time of the function
total_function_end <- Sys.time()
total_function_time <- as.numeric(total_function_end - total_function_start, units = "secs")
print(paste("Execution time for TOTAL FUNCTION: ", total_function_time, "seconds"))
# Return the plots, optimal strategy, and data frames of results
return(list(plot_lowest_cum_returns, optimal_strategy, plot_optimal_strategy, df_above_threshold, df_refused, plot_list_different_periods_within_strategies, total_function_time))
}
#' @param minimum_allowable_percentage The minimum allowable cumulative return percentage below which a strategy should be excluded.
#'
#' @return A list containing the following elements:
#' - plot_lowest_cum_returns: a ggplot object illustrating the evolution of the lowest cumulative return series for each investment strategy.
#' - optimal_strategy: the optimal investment strategy identified.
#' - plot_optimal_strategy: a ggplot object that visualizes worst-case, best-case, and other return series for the optimal strategy.
#' - df_above_threshold: a data frame containing strategies that have not been excluded, their lowest and highest cumulative returns.
#' - df_refused: a data frame containing excluded strategies, their lowest and highest cumulative returns.
#' - plot_list_different_periods_within_strategies: a list of ggplot objects, each representing cumulative returns for different starting dates for a particular strategy.
#'
determine_optimal_strategy_v1 <- function(df_return_series, time_horizon_years, minimum_allowable_percentage) {
# Start timer for performance tracking
total_function_start <- Sys.time()
# Initialize constants and variables
days_per_year <- 252
time_horizon_days <- time_horizon_years * days_per_year
# Initialize data frames to store results
df_above_threshold <- data.frame(Strategy = character(), LowestCumulativeReturn = numeric())
df_refused <- data.frame(Strategy = character(), LowestCumulativeReturn = numeric())
# Initialize lists to store the lowest and highest return series for each strategy
lowest_series <- list()
highest_series <- list()
# Initialize a list to store return series of the optimal strategy
optimal_strategy_series <- list()
# Initialize a list to store ggplot objects for each strategy.
# Each ggplot object represents cumulative returns for different starting dates for a particular strategy.
plot_list_different_periods_within_strategies <- list()
# Main loop over each strategy
for (col in names(df_return_series)[-1]) {
# Initialization of variables for current strategy
lowest_cumulative_return <- Inf
highest_cumulative_return <- -Inf
lowest_cumulative_series <- NULL
highest_cumulative_series <- NULL
exclude <- FALSE
df_series_to_plot <- data.frame()
# Loop over all possible starting times for the specified time horizon
for (i in 1:(nrow(df_return_series) - time_horizon_days + 1)) {
# Compute cumulative returns for the current time period
cum_returns_time_period <- cumprod(1 + df_return_series[i:(i + time_horizon_days - 1), col])
# Compute series to plot for every year (for visualization purposes)
if(i %% 252 == 0) {
df <- data.frame(Year = 1:length(cum_returns_time_period)/252,
CumReturns = cum_returns_time_period,
Series_ID = paste("Series", i)) # Identifier for each series
# Combine this df with the df for all series
df_series_to_plot <- rbind(df_series_to_plot, df)
}
# Check if the minimum cumulative return is below the threshold and set the flag to exclude the strategy if so
if (any(cum_returns_time_period < minimum_allowable_percentage)) {
exclude <- TRUE
################# break # We deleted this break from the code, because we are still interested in all the graphs
}
# Keep track of the lowest cumulative return for the current strategy
if (cum_returns_time_period[length(cum_returns_time_period)] < lowest_cumulative_return) {
lowest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
lowest_cumulative_series <- cum_returns_time_period
}
# Keep track of the highest cumulative return for the current strategy
if (cum_returns_time_period[length(cum_returns_time_period)] > highest_cumulative_return) {
highest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
highest_cumulative_series <- cum_returns_time_period
}
}
# Generate plot displaying all series of cumulative returns for the current investment strategy.
# Each series represents a different start time within the time horizon.
plot_different_periods_within_strategy <-
ggplot(df_series_to_plot, aes(x=Year, y=CumReturns, color=Series_ID)) +
geom_line() +
geom_hline(yintercept = minimum_allowable_percentage, linetype = "dashed", color = "red") +
labs(x = "Years invested", y = "Cumulative Return", title = paste("Cumulative returns for different starting dates (subset of actual analysis), for", col)) +
theme(legend.position="none") +
scale_y_continuous(limits = c(0, NA))
# The resulting plot is added to the list `plot_list_different_periods_within_strategies` for later use.
plot_list_different_periods_within_strategies[[col]] <- plot_different_periods_within_strategy
# If the strategy is marked for exclusion, add to df_refused, else add to df_above_threshold
if (exclude == TRUE) {
df_refused <- rbind(df_refused, data.frame(Strategy = col, LowestCumulativeReturn = lowest_cumulative_return, HighestCumulativeReturn = highest_cumulative_return))
lowest_series[[col]] <- lowest_cumulative_series
highest_series[[col]] <- highest_cumulative_series
} else {
df_above_threshold <- rbind(df_above_threshold, data.frame(Strategy = col, LowestCumulativeReturn = lowest_cumulative_return, HighestCumulativeReturn = highest_cumulative_return))
lowest_series[[col]] <- lowest_cumulative_series
highest_series[[col]] <- highest_cumulative_series
}
}
# Select the optimal strategy as the one with the highest minimum cumulative return that didn't fall below the threshold
optimal_strategy <- df_above_threshold[which.max(df_above_threshold$LowestCumulativeReturn), "Strategy"]
# Prepare data for plotting lowest cumulative returns for each strategy, categorizing them as above_threshold or excluded
plot_lowest_cum_returns_data <- do.call(rbind, lapply(names(lowest_series), function(name) {
group <- ifelse(name %in% df_above_threshold$Strategy, "above_threshold", "excluded")
data.frame(Year = 1:length(lowest_series[[name]])/252, Return = lowest_series[[name]], Strategy = name, Group = group, stringsAsFactors = FALSE)
}))
# Assign colors for the plot: 'darkgreen' for strategies above threshold and 'gray90' for excluded strategies
color_mapping <- setNames(ifelse(unique(plot_lowest_cum_returns_data$Strategy) %in% df_above_threshold$Strategy, "darkgreen", "gray90"), unique(plot_lowest_cum_returns_data$Strategy))
# Rearrange the order of the 'Group' factor to ensure 'above_threshold' group is plotted last (and therefore on top)
plot_lowest_cum_returns_data$Group <- factor(plot_lowest_cum_returns_data$Group, levels = c("excluded", "above_threshold"))
# Generate a plot illustrating the evolution of the lowest cumulative return series for each investment strategy
# Strategies are color-coded based on group - 'above_threshold' and 'excluded'
plot_lowest_cum_returns <-
ggplot(plot_lowest_cum_returns_data, aes(x = Year, y = Return, color = Strategy, group = Strategy)) +
geom_line(data = subset(plot_lowest_cum_returns_data, Group == "excluded")) +
geom_line(data = subset(plot_lowest_cum_returns_data, Group == "above_threshold")) +
scale_color_manual(values = color_mapping) +
geom_hline(yintercept = minimum_allowable_percentage, linetype = "dashed", color = "red") +
labs(title = "Lowest cumulative return series, for each candidate investment strategy", x = "Years invested", y = "Cumulative return") +
theme_minimal() +
theme(legend.position="none") +
scale_y_continuous(limits = c(0, NA))
# Extract plot data for the optimal strategy
plot_optimal_strategy_data <- ggplot_build(plot_list_different_periods_within_strategies[[optimal_strategy]])$data[[1]]
# Generate a plot that visualizes worst-case, best-case, and other return series for the optimal strategy
plot_optimal_strategy <-
ggplot() +
geom_line(data = plot_optimal_strategy_data, aes(x = x, y = y, color = colour), alpha = 0.2) +
geom_line(data = data.frame(Year = 1:length(lowest_series[[optimal_strategy]])/252, Return = lowest_series[[optimal_strategy]]), aes(x = Year, y = Return), color = "red") +
geom_line(data = data.frame(Year = 1:length(highest_series[[optimal_strategy]])/252, Return = highest_series[[optimal_strategy]]), aes(x = Year, y = Return), color = "green") +
geom_hline(yintercept = minimum_allowable_percentage, linetype = "dashed", color = "red") +
labs(title = paste("Worst-case, best-case and other historic return series for your optimal strategy:", optimal_strategy), x = "Years invested", y = "Cumulative return") +
theme_minimal() +
theme(legend.position="none") +
scale_y_continuous(limits = c(0, NA))
# Compute and print the total execution time of the function
total_function_end <- Sys.time()
total_function_time <- as.numeric(total_function_end - total_function_start, units = "secs")
print(paste("Execution time for TOTAL FUNCTION: ", total_function_time, "seconds"))
# Return the plots, optimal strategy, and data frames of results
return(list(plot_lowest_cum_returns, optimal_strategy, plot_optimal_strategy, df_above_threshold, df_refused, plot_list_different_periods_within_strategies, total_function_time))
}
0.60:0.80
seq(0.50, 0.75, 0.25)
seq(8, 12, 4)
gc()
# Define the range of years and minimum allowable percentage to compare different strategies over different time horizons and thresholds
your_time_horizon_years = seq(8, 12, 4)
your_minimum_allowable_percentage <- seq(0.50, 0.75, 0.25)
# Initialize an empty data frame to store the comparison results
df_compare_determine_optimal_strategy_v1 <- data.frame()
# Compare different strategies for various time horizons and minimum allowable percentages
# Iterate over different values of years and minimum_value
for(years in your_time_horizon_years) {
for(minimum_value in your_minimum_allowable_percentage) {
# Call the function determine_optimal_strategy_v1 with the specified input parameters
your_candidate_strategies_results_v1 <- determine_optimal_strategy_v1(df_return_series = index_daily_returns_CHF,
time_horizon_years = years,
minimum_allowable_percentage = minimum_value)
# Extract the results from the function output into individual variables
your_plot_lowest_returns_for_each_strategy <- your_candidate_strategies_results_v1[[1]]
your_optimal_strategy <- your_candidate_strategies_results_v1[[2]]
your_plot_optimal_strategy <- your_candidate_strategies_results_v1[[3]]
your_strategies_above_threshold <- your_candidate_strategies_results_v1[[4]]
your_strategies_below_threshold <- your_candidate_strategies_results_v1[[5]]
your_plots_for_each_strategy <- your_candidate_strategies_results_v1[[6]]
your_total_function_time <- your_candidate_strategies_results_v1[[7]]
# Combine the extracted results into the df_compare_determine_optimal_strategy_v1 data frame
df_compare_determine_optimal_strategy_v1 <- rbind(df_compare_determine_optimal_strategy_v1,
data.frame(PlotLowestReturns = your_plot_lowest_returns_for_each_strategy,
OptimalStrategy = your_optimal_strategy,
PlotOptimalStrategy = your_plot_optimal_strategy,
StrategiesAboveThreshold = your_strategies_above_threshold,
StrategiesBelowThreshold = your_strategies_below_threshold,
PlotsForEachStrategy = your_plots_for_each_strategy,
TotalFunctionTime = your_total_function_time))
}
}
# Define the range of years and minimum allowable percentage to compare different strategies over different time horizons and thresholds
your_time_horizon_years = seq(8, 12, 4)
your_minimum_allowable_percentage <- seq(0.50, 0.75, 0.25)
# Initialize an empty data frame to store the comparison results
df_compare_determine_optimal_strategy_v1 <- data.frame()
# Compare different strategies for various time horizons and minimum allowable percentages
# Iterate over different values of years and minimum_value
for(years in your_time_horizon_years) {
for(minimum_value in your_minimum_allowable_percentage) {
# Call the function determine_optimal_strategy_v1 with the specified input parameters
your_candidate_strategies_results_v1 <- determine_optimal_strategy_v1(df_return_series = index_daily_returns_CHF,
time_horizon_years = years,
minimum_allowable_percentage = minimum_value)
# Extract the results from the function output into individual variables
your_plot_lowest_returns_for_each_strategy <- your_candidate_strategies_results_v1[[1]]
your_optimal_strategy <- your_candidate_strategies_results_v1[[2]]
your_plot_optimal_strategy <- your_candidate_strategies_results_v1[[3]]
your_strategies_above_threshold <- your_candidate_strategies_results_v1[[4]]
your_strategies_below_threshold <- your_candidate_strategies_results_v1[[5]]
your_plots_for_each_strategy <- your_candidate_strategies_results_v1[[6]]
your_total_function_time <- your_candidate_strategies_results_v1[[7]]
# Combine the extracted results into the df_compare_determine_optimal_strategy_v1 data frame
df_compare_determine_optimal_strategy_v1 <- rbind(df_compare_determine_optimal_strategy_v1,
data.frame(PlotLowestReturns = your_plot_lowest_returns_for_each_strategy,
OptimalStrategy = your_optimal_strategy,
PlotOptimalStrategy = your_plot_optimal_strategy,
StrategiesAboveThreshold = your_strategies_above_threshold,
StrategiesBelowThreshold = your_strategies_below_threshold,
PlotsForEachStrategy = your_plots_for_each_strategy,
TotalFunctionTime = your_total_function_time))
}
}
# Define the range of years and minimum allowable percentage to compare different strategies over different time horizons and thresholds
your_time_horizon_years = seq(8, 12, 4)
your_minimum_allowable_percentage <- seq(0.50, 0.75, 0.25)
# Initialize an empty data frame to store the comparison results
df_compare_determine_optimal_strategy_v1 <- data.frame()
# Compare different strategies for various time horizons and minimum allowable percentages
# Iterate over different values of years and minimum_value
for (years in your_time_horizon_years) {
for (minimum_value in your_minimum_allowable_percentage) {
# Call the function determine_optimal_strategy_v1 with the specified input parameters
your_candidate_strategies_results_v1 <- determine_optimal_strategy_v1(df_return_series = index_daily_returns_CHF,
time_horizon_years = years,
minimum_allowable_percentage = minimum_value)
# Extract the results from the function output into individual variables
your_plot_lowest_returns_for_each_strategy <- your_candidate_strategies_results_v1[[1]]
your_optimal_strategy <- your_candidate_strategies_results_v1[[2]]
your_plot_optimal_strategy <- your_candidate_strategies_results_v1[[3]]
your_strategies_above_threshold <- your_candidate_strategies_results_v1[[4]]
your_strategies_below_threshold <- your_candidate_strategies_results_v1[[5]]
your_plots_for_each_strategy <- your_candidate_strategies_results_v1[[6]]
your_total_function_time <- your_candidate_strategies_results_v1[[7]]
# Debugging code to print the variables
print(your_plot_lowest_returns_for_each_strategy)
print(your_optimal_strategy)
print(your_plot_optimal_strategy)
print(your_strategies_above_threshold)
print(your_strategies_below_threshold)
print(your_plots_for_each_strategy)
print(your_total_function_time)
# Combine the extracted results into the df_compare_determine_optimal_strategy_v1 data frame
df_compare_determine_optimal_strategy_v1 <- rbind(df_compare_determine_optimal_strategy_v1,
data.frame(PlotLowestReturns = your_plot_lowest_returns_for_each_strategy,
OptimalStrategy = your_optimal_strategy,
PlotOptimalStrategy = your_plot_optimal_strategy,
StrategiesAboveThreshold = your_strategies_above_threshold,
StrategiesBelowThreshold = your_strategies_below_threshold,
PlotsForEachStrategy = your_plots_for_each_strategy,
TotalFunctionTime = your_total_function_time))
}
}
# Define the range of years and minimum allowable percentage to compare different strategies over different time horizons and thresholds
your_time_horizon_years <- seq(8, 12, 4)
your_minimum_allowable_percentage <- seq(0.50, 0.75, 0.25)
# Initialize an empty data frame to store the comparison results
df_compare_determine_optimal_strategy_v1 <- data.frame()
# Initialize a list to store the ggplot objects
plot_list <- list()
# Compare different strategies for various time horizons and minimum allowable percentages
# Iterate over different values of years and minimum_value
for (years in your_time_horizon_years) {
for (minimum_value in your_minimum_allowable_percentage) {
# Call the function determine_optimal_strategy_v1 with the specified input parameters
your_candidate_strategies_results_v1 <- determine_optimal_strategy_v1(df_return_series = index_daily_returns_CHF,
time_horizon_years = years,
minimum_allowable_percentage = minimum_value)
# Extract the results from the function output into individual variables
your_plot_lowest_returns_for_each_strategy <- your_candidate_strategies_results_v1[[1]]
your_optimal_strategy <- your_candidate_strategies_results_v1[[2]]
your_plot_optimal_strategy <- your_candidate_strategies_results_v1[[3]]
your_strategies_above_threshold <- your_candidate_strategies_results_v1[[4]]
your_strategies_below_threshold <- your_candidate_strategies_results_v1[[5]]
your_plots_for_each_strategy <- your_candidate_strategies_results_v1[[6]]
your_total_function_time <- your_candidate_strategies_results_v1[[7]]
# Combine the extracted results into the df_compare_determine_optimal_strategy_v1 data frame
df_compare_determine_optimal_strategy_v1 <- rbind(df_compare_determine_optimal_strategy_v1,
data.frame(OptimalStrategy = your_optimal_strategy,
TotalFunctionTime = your_total_function_time))
# Append the plot objects to the plot_list
plot_list <- c(plot_list, your_plots_for_each_strategy)
}
}
# Combine the plots from the plot_list into a single ggplot object
combined_plots <- do.call(gridExtra::grid.arrange, plot_list)
# Print the combined_plots or perform further operations as needed
print(combined_plots)
# Print the combined_plots or perform further operations as needed
print(combined_plots)
View(combined_plots)
View(combined_plots)
# Define the range of years and minimum allowable percentage to compare different strategies over different time horizons and thresholds
your_time_horizon_years = seq(8, 12, 4)
your_minimum_allowable_percentage <- seq(0.50, 0.75, 0.25)
gc()
