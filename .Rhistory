density_plot_different_subsamples
density_plot_different_runs <- ggplot(data = df_means_500_subsamples_different_runs) +   geom_density(aes(x = means_500_subsamples_100_runs, color="100 draws")) +
geom_density(aes(x = means_500_subsamples_500_runs, color="500 draws")) +
geom_density(aes(x = means_500_subsamples_2500_runs, color="2500 draws")) +
labs(title="Density estimate for different number of draws (500 subsamples)", x="Mean soft drug consumption", y = "Density") +
xlim(0.20, 0.60) +
ylim(0,50) +
scale_colour_manual(name="", values = c("red", "green", "blue")) +
scale_color_discrete(breaks=c('100 draws', '500 draws', '2500 draws')) +
theme(legend.position="top")
density_plot_different_runs
density_plot_different_subsamples <- ggplot(data = df_means_different_samples_500_runs) +   geom_density(aes(x = means_100_subsamples_500_runs, color="100 subsamples")) +
geom_density(aes(x = means_500_subsamples_500_runs, color="500 subsamples")) +
geom_density(aes(x = means_2500_subsamples_500_runs, color="2500 subsamples")) +
labs(title="Density estimate for different subsample sizes (500 draws)", x="Mean soft drug consumption", y = "Density") +
xlim(0.20, 0.60) +
ylim(0,50) +
scale_colour_manual(name="", values = c("red", "green", "blue")) +
scale_color_discrete(breaks=c('100 subsamples', '500 subsamples', '2500 subsamples')) +
theme(legend.position="top")
density_plot_different_subsamples
# second kernel: visualizing density estimate for the three different number of draws
density_plot_different_runs <- ggplot(data = df_means_500_subsamples_different_runs) +   geom_density(aes(x = means_500_subsamples_100_runs, color="100 draws")) +
geom_density(aes(x = means_500_subsamples_500_runs, color="500 draws")) +
geom_density(aes(x = means_500_subsamples_2500_runs, color="2500 draws")) +
labs(title="Density estimate for different number of draws (500 subsamples)", x="Mean soft drug consumption", y = "Density") +
xlim(0.20, 0.60) +
ylim(0,50) +
scale_colour_manual(name="", values = c("red", "green", "blue")) +
scale_color_discrete(breaks=c('100 draws', '500 draws', '2500 draws')) +
theme(legend.position="top")
density_plot_different_runs
# Save all objects in the workspace to a file named 'my_workspace.RData'
# save.image('my_workspace.RData')
# Load the objects from 'my_workspace.RData' into the workspace
# It's a good practice to start a new session or clear the workspace before loading the saved objects.
load('my_workspace.RData')
# Assisted by ChatGPT (https://chat.openai.com/) while writing the code below.
# Load packages
library(combinat)
library(foreach)
library(doParallel)
library(readxl)
library(progress)
library(dplyr)
library(parallel)
library(future.apply)
library(progressr)
library(RSQLite)
library(DBI)
library(ggplot2)
library(reshape2)
library(scales)
library(zoo)
library(gridExtra)
##############################################################################
# Get the directory path of the current code file
PATH <- dirname(rstudioapi::getSourceEditorContext()$path)
# Set the working directory to that of the current code file
setwd(PATH)
# Load functions file
source("BDA_BDBD_functions - Luca.R")
##############################################################################
# DATA COLLECTION: leveraging data from multiple sources
# Loading the raw data into R from different sources, each with different data formats.
# Load raw data for prices of selected indices
data_indices_full <- read_excel("Bloomberg_Terminal-spreadsheet_builder.xlsx", sheet = 1, col_names = FALSE)
index_prices_local_currency <- data_indices_full[7:nrow(data_indices_full), ]
colnames(index_prices_local_currency) <- data_indices_full[4, ]
names(index_prices_local_currency)[1] <- "Dates"
index_prices_local_currency$Dates <- as.Date(as.numeric(index_prices_local_currency$Dates), origin = "1899-12-30")
# Load raw data for prices of selected indices
data_FX_full <- read_excel("Bloomberg_Terminal-spreadsheet_builder.xlsx", sheet = 2, col_names = FALSE)
CHF_FX <- data_FX_full[7:nrow(data_indices_full), ]
colnames(CHF_FX) <- data_FX_full[4, ]
names(CHF_FX)[1] <- "Dates"
CHF_FX$Dates <- as.Date(as.numeric(CHF_FX$Dates), origin = "1899-12-30")
# Load raw data for Swiss inflation (CPI in %)
data_inflation_full <- read_excel("API_FP.CPI.TOTL.ZG_DS2_en_excel_v2_5454868.xls", sheet = 1, col_names = FALSE)
data_inflation <- data.frame(t(data_inflation_full[4:nrow(data_inflation_full), ]))
colnames(data_inflation) <- data_inflation[1, ]
data_inflation <- data_inflation[-(1:4), ]
names(data_inflation)[1] <- "Dates"
swiss_inflation <- data_inflation[, c('Dates', 'Switzerland')]
# Load and merge raw data for CHF money market rates and CHF spot interest rates on Swiss Confederation bond issues
data_ST_rf_CHF <- read_excel("snb-chart-data-zimomach-en-all-20230502_1430.xlsx", skip = 15, col_names = TRUE)
data_LT_rf_CHF <- read_excel("snb-chart-data-rendeidglfzch-en-all-20230502_1430.xlsx", skip = 15, col_names = TRUE)
names(data_ST_rf_CHF)[1] <- "Dates"
names(data_LT_rf_CHF)[1] <- "Dates"
data_ST_rf_CHF <- data_ST_rf_CHF[, c('Dates', 'SARON close of trading')]
CHF_rf_rates <- merge(data_ST_rf_CHF, data_LT_rf_CHF, by = "Dates", all = TRUE)
# Inspect the size of the downloaded data
print(paste("data_indices_full (downloaded):", round(object.size(data_indices_full) / 1048576, 2), "MB"))
print(paste("data_FX_full (downloaded):", round(object.size(data_FX_full) / 1048576, 2), "MB"))
print(paste("data_inflation_full (downloaded):", round(object.size(data_inflation_full) / 1048576, 2), "MB"))
print(paste("data_ST_rf_CHF (downloaded):", round(object.size(data_ST_rf_CHF) / 1048576, 2), "MB"))
print(paste("data_ST_rf_CHF (downloaded):", round(object.size(data_ST_rf_CHF) / 1048576, 2), "MB"))
# Remove from our R environment the variables that we no longer need
rm(data_indices_full, data_FX_full, data_inflation_full, data_inflation, data_ST_rf_CHF, data_LT_rf_CHF)
# Inspect the size of the raw data that we continue from
print(paste("index_prices_local_currency:", round(object.size(index_prices_local_currency) / 1048576, 2), "MB"))
print(paste("CHF_FX:", round(object.size(CHF_FX) / 1048576, 2), "MB"))
print(paste("CHF_rf_rates:", round(object.size(CHF_rf_rates) / 1048576, 2), "MB"))
print(paste("swiss_inflation:", round(object.size(swiss_inflation) / 1048576, 2), "MB"))
##############################################################################
# DATA CLEANING AND DATA INTEGRATION
# Inspect classes of the Dates columns of the different data frames
class(index_prices_local_currency$Dates)
class(CHF_FX$Dates)
class(swiss_inflation$Dates)
class(CHF_rf_rates$Dates)
# Convert Dates to a Date object
index_prices_local_currency$Dates <- as.Date(index_prices_local_currency$Dates)
CHF_FX$Dates <- as.Date(CHF_FX$Dates)
CHF_rf_rates$Dates <- as.Date(CHF_rf_rates$Dates)
swiss_inflation$Dates <- as.Date(paste(swiss_inflation$Dates, "-01-01", sep = ""), format = "%Y-%m-%d")
# Sort the data frames by the 'Dates' column in descending order (from most recent to older)
index_prices_local_currency <- index_prices_local_currency[order(index_prices_local_currency$Dates, decreasing = TRUE),]
CHF_FX <- CHF_FX[order(CHF_FX$Dates, decreasing = TRUE),]
swiss_inflation <- swiss_inflation[order(swiss_inflation$Dates, decreasing = TRUE),]
CHF_rf_rates <- CHF_rf_rates[order(CHF_rf_rates$Dates, decreasing = TRUE),]
# Change the column name for Swiss inflation (CPI in %) and convert the data to actual percentages
if (names(swiss_inflation)[2] == "Switzerland") {
names(swiss_inflation)[2] <- "Swiss inflation (CPI)"
swiss_inflation$"Swiss inflation (CPI)" <- as.numeric(swiss_inflation$"Swiss inflation (CPI)") / 100
}
# Convert "#N/A N/A" to NA (in character or factor columns only)
is_char_or_factor <- sapply(index_prices_local_currency, function(col) is.character(col) | is.factor(col))
index_prices_local_currency[is_char_or_factor] <- lapply(index_prices_local_currency[is_char_or_factor], function(col) {
ifelse(col == "#N/A N/A", NA, col)
})
is_char_or_factor <- sapply(CHF_FX, function(col) is.character(col) | is.factor(col))
CHF_FX[is_char_or_factor] <- lapply(CHF_FX[is_char_or_factor], function(col) {
ifelse(col == "#N/A N/A", NA, col)
})
# Determine indices that do not contain sufficiently long dated price data and are not essential to the investment universe
index_prices_local_currency_NA_dates <- determine_start_dates(index_prices_local_currency)
print(index_prices_local_currency_NA_dates)
# Remove indices (columns) that do not contain sufficiently long dated price data and are not essential to the investment universe
# --> removing mid cap equity indices (insufficiently long dated price data for Switzerland, remove the corresponding index for other geographies, and total stock market index already covers large- and mid-cap equity)
# --> removing large cap equity indices (total stock market index already covers large- and mid-cap equity)
# --> removing real estate index (insufficiently long dated price data)
# --> removing 2 duplicates of I08240CH
index_prices_local_currency <- index_prices_local_currency[, !(colnames(index_prices_local_currency) %in% c("MXCHMC Index", "MXEUMC Index", "MXUSMC Index", "MXEFMC Index", "MXWOMC Index",
"MXUSLC Index", "MXEULC Index", "MXEFLC Index", "MXCHLC Index", "MXWOLC Index",
"TENHGU Index",
"I08240 Index", "I08240EU Index"))]
# Determine currency pairs that do not contain sufficiently long dated price data and are not essential to the investment universe
CHF_FX_NA_dates <- determine_start_dates(CHF_FX)
print(CHF_FX_NA_dates)
# Remove currency pairs (columns) that do not contain sufficiently long dated price data and are not essential to the investment universe
# NOT APPLICABLE
# Provide better names to remaining columns of dataframes index_prices_local_currency and CHF_FX
index_prices_local_currency <- rename_columns(index_prices_local_currency)
CHF_FX <- rename_columns(CHF_FX)
# Transform non-NA values from character to numeric
index_prices_local_currency <- index_prices_local_currency %>%
mutate_at(
vars(-Dates),
~as.numeric(na_if(., ""))  # Convert non-empty strings to numeric
)
CHF_FX <- CHF_FX %>%
mutate_at(
vars(-Dates),
~as.numeric(na_if(., ""))  # Convert non-empty strings to numeric
)
# For each geography, combine the three intermediate-term treasuries (3-5Y, 5-7Y, 7-10Y) into one investable security that is weighted 1/3 in each
index_prices_local_currency <- index_prices_local_currency %>%
mutate(`US IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`US IT treasuries 3-5Y` + `US IT treasuries 5-7Y` + `US IT treasuries 7-10Y`) / 3,
`Europe IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`Europe IT treasuries 3-5Y` + `Europe IT treasuries 5-7Y` + `Europe IT treasuries 7-10Y`) / 3,
`EM IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`EM IT treasuries 3-5Y` + `EM IT treasuries 5-7Y` + `EM IT treasuries 7-10Y`) / 3,
`Switzerland IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`Switzerland IT treasuries 3-5Y` + `Switzerland IT treasuries 5-7Y` + `Switzerland IT treasuries 7-10Y`) / 3,
`World IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`World IT treasuries 3-5Y` + `World IT treasuries 5-7Y` + `World IT treasuries 7-10Y`) / 3)
# Remove the original intermediate-term treasuries columns
index_prices_local_currency <- index_prices_local_currency %>%
select(-ends_with("3-5Y"), -ends_with("5-7Y"), -ends_with("7-10Y"))
# Rearrange the indices (columns) to a more logical order
index_prices_local_currency <- rearrange_columns(index_prices_local_currency)
# Remove longer dated observations until each column contains values for each remaining date (row)
# i.e. Filter the data frames to include only rows starting from the latest start date
index_prices_local_currency <- filter(index_prices_local_currency,
Dates > max(determine_start_dates(index_prices_local_currency)))
CHF_FX <- filter(CHF_FX,
Dates >= max(determine_start_dates(index_prices_local_currency)))
CHF_rf_rates <- filter(CHF_rf_rates,
Dates >= max(determine_start_dates(index_prices_local_currency)))
# To prepare for upcoming analysis: sort data frames from oldest observations (at the top) to most recent observations (at the bottom)
index_prices_local_currency <- index_prices_local_currency %>%
arrange(Dates)
CHF_FX <- CHF_FX %>%
arrange(Dates)
swiss_inflation <- swiss_inflation %>%
arrange(Dates)
CHF_rf_rates <- CHF_rf_rates %>%
arrange(Dates)
# Generate dataframe containing index prices in CHF (calculated from index_prices_local_currency and CHF_FX)
# Initialize dataframe that will contain index prices in CHF
index_prices_CHF <- index_prices_local_currency
# Select the columns representing USD, EUR, and CHF denominated indexes
usd_indexes <- c("US", "US small cap", "Europe small cap", "EM", "EM small cap", "Switzerland small cap", "World", "World small cap", "US ST treasuries 1-3Y", "US IT treasuries (3-5Y, 5-7Y, 7-10Y)", "US LT treasuries 10Y+", "EM ST treasuries 1-3Y", "EM IT treasuries (3-5Y, 5-7Y, 7-10Y)", "EM LT treasuries 10Y+", "World ST treasuries 1-3Y", "World IT treasuries (3-5Y, 5-7Y, 7-10Y)", "World LT treasuries 10Y+", "Gold bullion")
eur_indexes <- c("Europe", "Europe ST treasuries 1-3Y", "Europe IT treasuries (3-5Y, 5-7Y, 7-10Y)", "Europe LT treasuries 10Y+")
chf_indexes <- c("Switzerland", "Switzerland ST treasuries 1-3Y", "Switzerland IT treasuries (3-5Y, 5-7Y, 7-10Y)", "Switzerland LT treasuries 10Y+")
# Multiply USD denominated columns by CHF/USD exchange rate
index_prices_CHF[, usd_indexes] <- index_prices_CHF[, usd_indexes] * CHF_FX[["CHF per USD"]]
# Multiply EUR denominated columns by CHF/EUR exchange rate
index_prices_CHF[, eur_indexes] <- index_prices_CHF[, eur_indexes] * CHF_FX[["CHF per EUR"]]
# Inspect dataframe index_prices_CHF
print(index_prices_CHF)
colnames(index_prices_CHF)
head(index_prices_CHF, 10)
tail(index_prices_CHF, 10)
# Generate dataframe containing daily price returns in CHF (calculated from index_prices_CHF)
# Initialize dataframe that will contain daily price returns in CHF
index_daily_returns_CHF <- data.frame(index_prices_CHF$Dates)
names(index_daily_returns_CHF)[1] <- "Dates"
# Calculate daily price returns for each index in CHF
num_rows <- nrow(index_prices_CHF)
for (col in colnames(index_prices_CHF)[-1]) {
prices <- index_prices_CHF[[col]]
returns <- (prices[2:num_rows] / prices[1:(num_rows - 1)]) - 1
index_daily_returns_CHF[[col]] <- c(NA, returns)
}
index_daily_returns_CHF <- na.omit(index_daily_returns_CHF) # This removes the first row, which only contains returns of value NA
# Inspect the size of the cleaned data that we continue from
print(paste("index_daily_returns_CHF:", round(object.size(index_daily_returns_CHF) / 1048576, 2), "MB"))
print(paste("CHF_FX:", round(object.size(CHF_FX) / 1048576, 2), "MB"))
print(paste("CHF_rf_rates:", round(object.size(CHF_rf_rates) / 1048576, 2), "MB"))
print(paste("swiss_inflation:", round(object.size(swiss_inflation) / 1048576, 2), "MB"))
# Generate new columns (different investment strategies of equally-weighted indices) from our daily index returns in CHF
strategies_max_2_comb_daily_rebal <- generate_weighted_cols(index_daily_returns_CHF, 2)
strategies_max_3_comb_daily_rebal <- generate_weighted_cols(index_daily_returns_CHF, 3)
# Assisted by ChatGPT (https://chat.openai.com/) while writing the code below.
# Load packages
library(combinat)
library(foreach)
library(doParallel)
library(readxl)
library(progress)
library(dplyr)
library(parallel)
library(future.apply)
library(progressr)
library(RSQLite)
library(DBI)
library(ggplot2)
library(reshape2)
library(scales)
library(zoo)
library(gridExtra)
# Get the directory path of the current code file
PATH <- dirname(rstudioapi::getSourceEditorContext()$path)
# Set the working directory to that of the current code file
setwd(PATH)
# Load functions file
source("BDA_BDBD_functions - Luca.R")
##############################################################################
# DATA COLLECTION: leveraging data from multiple sources
# Loading the raw data into R from different sources, each with different data formats.
# Load raw data for prices of selected indices
data_indices_full <- read_excel("Bloomberg_Terminal-spreadsheet_builder.xlsx", sheet = 1, col_names = FALSE)
index_prices_local_currency <- data_indices_full[7:nrow(data_indices_full), ]
colnames(index_prices_local_currency) <- data_indices_full[4, ]
names(index_prices_local_currency)[1] <- "Dates"
index_prices_local_currency$Dates <- as.Date(as.numeric(index_prices_local_currency$Dates), origin = "1899-12-30")
# Load raw data for prices of selected indices
data_FX_full <- read_excel("Bloomberg_Terminal-spreadsheet_builder.xlsx", sheet = 2, col_names = FALSE)
CHF_FX <- data_FX_full[7:nrow(data_indices_full), ]
colnames(CHF_FX) <- data_FX_full[4, ]
names(CHF_FX)[1] <- "Dates"
CHF_FX$Dates <- as.Date(as.numeric(CHF_FX$Dates), origin = "1899-12-30")
# Load raw data for Swiss inflation (CPI in %)
data_inflation_full <- read_excel("API_FP.CPI.TOTL.ZG_DS2_en_excel_v2_5454868.xls", sheet = 1, col_names = FALSE)
data_inflation <- data.frame(t(data_inflation_full[4:nrow(data_inflation_full), ]))
colnames(data_inflation) <- data_inflation[1, ]
data_inflation <- data_inflation[-(1:4), ]
names(data_inflation)[1] <- "Dates"
swiss_inflation <- data_inflation[, c('Dates', 'Switzerland')]
# Load and merge raw data for CHF money market rates and CHF spot interest rates on Swiss Confederation bond issues
data_ST_rf_CHF <- read_excel("snb-chart-data-zimomach-en-all-20230502_1430.xlsx", skip = 15, col_names = TRUE)
data_LT_rf_CHF <- read_excel("snb-chart-data-rendeidglfzch-en-all-20230502_1430.xlsx", skip = 15, col_names = TRUE)
names(data_ST_rf_CHF)[1] <- "Dates"
names(data_LT_rf_CHF)[1] <- "Dates"
data_ST_rf_CHF <- data_ST_rf_CHF[, c('Dates', 'SARON close of trading')]
CHF_rf_rates <- merge(data_ST_rf_CHF, data_LT_rf_CHF, by = "Dates", all = TRUE)
# Inspect the size of the downloaded data
print(paste("data_indices_full (downloaded):", round(object.size(data_indices_full) / 1048576, 2), "MB"))
print(paste("data_FX_full (downloaded):", round(object.size(data_FX_full) / 1048576, 2), "MB"))
print(paste("data_inflation_full (downloaded):", round(object.size(data_inflation_full) / 1048576, 2), "MB"))
print(paste("data_ST_rf_CHF (downloaded):", round(object.size(data_ST_rf_CHF) / 1048576, 2), "MB"))
print(paste("data_ST_rf_CHF (downloaded):", round(object.size(data_ST_rf_CHF) / 1048576, 2), "MB"))
# Remove from our R environment the variables that we no longer need
rm(data_indices_full, data_FX_full, data_inflation_full, data_inflation, data_ST_rf_CHF, data_LT_rf_CHF)
# Inspect the size of the raw data that we continue from
print(paste("index_prices_local_currency:", round(object.size(index_prices_local_currency) / 1048576, 2), "MB"))
print(paste("CHF_FX:", round(object.size(CHF_FX) / 1048576, 2), "MB"))
print(paste("CHF_rf_rates:", round(object.size(CHF_rf_rates) / 1048576, 2), "MB"))
print(paste("swiss_inflation:", round(object.size(swiss_inflation) / 1048576, 2), "MB"))
# Inspect the size of the raw data that we continue from
print(paste("index_prices_local_currency:", round(object.size(index_prices_local_currency) / 1048576, 2), "MB"))
print(paste("CHF_FX:", round(object.size(CHF_FX) / 1048576, 2), "MB"))
print(paste("CHF_rf_rates:", round(object.size(CHF_rf_rates) / 1048576, 2), "MB"))
print(paste("swiss_inflation:", round(object.size(swiss_inflation) / 1048576, 2), "MB"))
##############################################################################
# DATA CLEANING AND DATA INTEGRATION
# Inspect classes of the Dates columns of the different data frames
class(index_prices_local_currency$Dates)
class(CHF_FX$Dates)
class(swiss_inflation$Dates)
class(CHF_rf_rates$Dates)
# Convert Dates to a Date object
index_prices_local_currency$Dates <- as.Date(index_prices_local_currency$Dates)
CHF_FX$Dates <- as.Date(CHF_FX$Dates)
CHF_rf_rates$Dates <- as.Date(CHF_rf_rates$Dates)
swiss_inflation$Dates <- as.Date(paste(swiss_inflation$Dates, "-01-01", sep = ""), format = "%Y-%m-%d")
# Sort the data frames by the 'Dates' column in descending order (from most recent to older)
index_prices_local_currency <- index_prices_local_currency[order(index_prices_local_currency$Dates, decreasing = TRUE),]
CHF_FX <- CHF_FX[order(CHF_FX$Dates, decreasing = TRUE),]
swiss_inflation <- swiss_inflation[order(swiss_inflation$Dates, decreasing = TRUE),]
CHF_rf_rates <- CHF_rf_rates[order(CHF_rf_rates$Dates, decreasing = TRUE),]
# Change the column name for Swiss inflation (CPI in %) and convert the data to actual percentages
if (names(swiss_inflation)[2] == "Switzerland") {
names(swiss_inflation)[2] <- "Swiss inflation (CPI)"
swiss_inflation$"Swiss inflation (CPI)" <- as.numeric(swiss_inflation$"Swiss inflation (CPI)") / 100
}
# Convert "#N/A N/A" to NA (in character or factor columns only)
is_char_or_factor <- sapply(index_prices_local_currency, function(col) is.character(col) | is.factor(col))
index_prices_local_currency[is_char_or_factor] <- lapply(index_prices_local_currency[is_char_or_factor], function(col) {
ifelse(col == "#N/A N/A", NA, col)
})
is_char_or_factor <- sapply(CHF_FX, function(col) is.character(col) | is.factor(col))
CHF_FX[is_char_or_factor] <- lapply(CHF_FX[is_char_or_factor], function(col) {
ifelse(col == "#N/A N/A", NA, col)
})
# Determine indices that do not contain sufficiently long dated price data and are not essential to the investment universe
index_prices_local_currency_NA_dates <- determine_start_dates(index_prices_local_currency)
print(index_prices_local_currency_NA_dates)
# Remove indices (columns) that do not contain sufficiently long dated price data and are not essential to the investment universe
# --> removing mid cap equity indices (insufficiently long dated price data for Switzerland, remove the corresponding index for other geographies, and total stock market index already covers large- and mid-cap equity)
# --> removing large cap equity indices (total stock market index already covers large- and mid-cap equity)
# --> removing real estate index (insufficiently long dated price data)
# --> removing 2 duplicates of I08240CH
index_prices_local_currency <- index_prices_local_currency[, !(colnames(index_prices_local_currency) %in% c("MXCHMC Index", "MXEUMC Index", "MXUSMC Index", "MXEFMC Index", "MXWOMC Index",
"MXUSLC Index", "MXEULC Index", "MXEFLC Index", "MXCHLC Index", "MXWOLC Index",
"TENHGU Index",
"I08240 Index", "I08240EU Index"))]
# Determine currency pairs that do not contain sufficiently long dated price data and are not essential to the investment universe
CHF_FX_NA_dates <- determine_start_dates(CHF_FX)
print(CHF_FX_NA_dates)
# Remove currency pairs (columns) that do not contain sufficiently long dated price data and are not essential to the investment universe
# NOT APPLICABLE
# Provide better names to remaining columns of dataframes index_prices_local_currency and CHF_FX
index_prices_local_currency <- rename_columns(index_prices_local_currency)
CHF_FX <- rename_columns(CHF_FX)
# Transform non-NA values from character to numeric
index_prices_local_currency <- index_prices_local_currency %>%
mutate_at(
vars(-Dates),
~as.numeric(na_if(., ""))  # Convert non-empty strings to numeric
)
CHF_FX <- CHF_FX %>%
mutate_at(
vars(-Dates),
~as.numeric(na_if(., ""))  # Convert non-empty strings to numeric
)
# For each geography, combine the three intermediate-term treasuries (3-5Y, 5-7Y, 7-10Y) into one investable security that is weighted 1/3 in each
index_prices_local_currency <- index_prices_local_currency %>%
mutate(`US IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`US IT treasuries 3-5Y` + `US IT treasuries 5-7Y` + `US IT treasuries 7-10Y`) / 3,
`Europe IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`Europe IT treasuries 3-5Y` + `Europe IT treasuries 5-7Y` + `Europe IT treasuries 7-10Y`) / 3,
`EM IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`EM IT treasuries 3-5Y` + `EM IT treasuries 5-7Y` + `EM IT treasuries 7-10Y`) / 3,
`Switzerland IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`Switzerland IT treasuries 3-5Y` + `Switzerland IT treasuries 5-7Y` + `Switzerland IT treasuries 7-10Y`) / 3,
`World IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`World IT treasuries 3-5Y` + `World IT treasuries 5-7Y` + `World IT treasuries 7-10Y`) / 3)
# Remove the original intermediate-term treasuries columns
index_prices_local_currency <- index_prices_local_currency %>%
select(-ends_with("3-5Y"), -ends_with("5-7Y"), -ends_with("7-10Y"))
# Rearrange the indices (columns) to a more logical order
index_prices_local_currency <- rearrange_columns(index_prices_local_currency)
# Remove longer dated observations until each column contains values for each remaining date (row)
# i.e. Filter the data frames to include only rows starting from the latest start date
index_prices_local_currency <- filter(index_prices_local_currency,
Dates > max(determine_start_dates(index_prices_local_currency)))
CHF_FX <- filter(CHF_FX,
Dates >= max(determine_start_dates(index_prices_local_currency)))
CHF_rf_rates <- filter(CHF_rf_rates,
Dates >= max(determine_start_dates(index_prices_local_currency)))
# To prepare for upcoming analysis: sort data frames from oldest observations (at the top) to most recent observations (at the bottom)
index_prices_local_currency <- index_prices_local_currency %>%
arrange(Dates)
CHF_FX <- CHF_FX %>%
arrange(Dates)
swiss_inflation <- swiss_inflation %>%
arrange(Dates)
CHF_rf_rates <- CHF_rf_rates %>%
arrange(Dates)
# Generate dataframe containing index prices in CHF (calculated from index_prices_local_currency and CHF_FX)
# Initialize dataframe that will contain index prices in CHF
index_prices_CHF <- index_prices_local_currency
# Select the columns representing USD, EUR, and CHF denominated indexes
usd_indexes <- c("US", "US small cap", "Europe small cap", "EM", "EM small cap", "Switzerland small cap", "World", "World small cap", "US ST treasuries 1-3Y", "US IT treasuries (3-5Y, 5-7Y, 7-10Y)", "US LT treasuries 10Y+", "EM ST treasuries 1-3Y", "EM IT treasuries (3-5Y, 5-7Y, 7-10Y)", "EM LT treasuries 10Y+", "World ST treasuries 1-3Y", "World IT treasuries (3-5Y, 5-7Y, 7-10Y)", "World LT treasuries 10Y+", "Gold bullion")
eur_indexes <- c("Europe", "Europe ST treasuries 1-3Y", "Europe IT treasuries (3-5Y, 5-7Y, 7-10Y)", "Europe LT treasuries 10Y+")
chf_indexes <- c("Switzerland", "Switzerland ST treasuries 1-3Y", "Switzerland IT treasuries (3-5Y, 5-7Y, 7-10Y)", "Switzerland LT treasuries 10Y+")
# Multiply USD denominated columns by CHF/USD exchange rate
index_prices_CHF[, usd_indexes] <- index_prices_CHF[, usd_indexes] * CHF_FX[["CHF per USD"]]
# Multiply EUR denominated columns by CHF/EUR exchange rate
index_prices_CHF[, eur_indexes] <- index_prices_CHF[, eur_indexes] * CHF_FX[["CHF per EUR"]]
# Inspect dataframe index_prices_CHF
print(index_prices_CHF)
colnames(index_prices_CHF)
head(index_prices_CHF, 10)
tail(index_prices_CHF, 10)
# Generate dataframe containing daily price returns in CHF (calculated from index_prices_CHF)
# Initialize dataframe that will contain daily price returns in CHF
index_daily_returns_CHF <- data.frame(index_prices_CHF$Dates)
names(index_daily_returns_CHF)[1] <- "Dates"
# Calculate daily price returns for each index in CHF
num_rows <- nrow(index_prices_CHF)
for (col in colnames(index_prices_CHF)[-1]) {
prices <- index_prices_CHF[[col]]
returns <- (prices[2:num_rows] / prices[1:(num_rows - 1)]) - 1
index_daily_returns_CHF[[col]] <- c(NA, returns)
}
index_daily_returns_CHF <- na.omit(index_daily_returns_CHF) # This removes the first row, which only contains returns of value NA
# Inspect the size of the cleaned data that we continue from
print(paste("index_daily_returns_CHF:", round(object.size(index_daily_returns_CHF) / 1048576, 2), "MB"))
print(paste("CHF_FX:", round(object.size(CHF_FX) / 1048576, 2), "MB"))
print(paste("CHF_rf_rates:", round(object.size(CHF_rf_rates) / 1048576, 2), "MB"))
print(paste("swiss_inflation:", round(object.size(swiss_inflation) / 1048576, 2), "MB"))
# Load functions file
source("BDA_BDBD_functions - Luca.R")
View(index_daily_returns_CHF)
View(index_daily_returns_CHF)
# Generate new columns (different investment strategies of equally-weighted indices) from our daily index returns in CHF
strategies_max_2_comb_daily_rebal <- generate_weighted_cols_daily_rebal(index_daily_returns_CHF, 2)
View(strategies_max_2_comb_daily_rebal)
View(strategies_max_2_comb_daily_rebal)
strategies_max_3_comb_daily_rebal <- generate_weighted_cols_daily_rebal(index_daily_returns_CHF, 3)
View(strategies_max_3_comb_daily_rebal)
View(strategies_max_3_comb_daily_rebal)
# Inspect (a subset of) the generated dataframes
head(strategies_max_2_comb_daily_rebal[, 1:30], 5)
# Inspect the size of the generated data that contains the different investment strategies
print(paste("strategies_max_2_comb_daily_rebal (generated):", round(object.size(strategies_max_2_comb_daily_rebal) / 1048576, 2), "MB"))
print(paste("strategies_max_3_comb_daily_rebal (generated):", round(object.size(strategies_max_3_comb_daily_rebal) / 1048576, 2), "MB"))
# Inspect the size of the generated data that contains the different investment strategies
print(paste("strategies_max_2_comb_daily_rebal (generated):", round(object.size(strategies_max_2_comb_daily_rebal) / 1048576, 2), "MB"))
print(paste("strategies_max_3_comb_daily_rebal (generated):", round(object.size(strategies_max_3_comb_daily_rebal) / 1048576, 2), "MB"))
# Plot the correlation matrix between returns of the initial 26 indices
plot_correlation_matrix(index_daily_returns_CHF)
# Plot the mean-variance graph for daily returns of each investment strategy in the data frame (first column is "Dates")
# First for only the 26 initial variables, than for all combinations up to 2, than for all higher number of combinations.
plot_mean_variance_graph(index_daily_returns_CHF)
plot_mean_variance_graph(strategies_max_2_comb_daily_rebal)
# Plot the mean-variance graph for daily returns of each investment strategy in the data frame (first column is "Dates")
# First for only the 26 initial variables, than for all combinations up to 2, than for all higher number of combinations.
plot_mean_variance_graph(index_daily_returns_CHF)
plot_mean_variance_graph(strategies_max_2_comb_daily_rebal)
plot_mean_variance_graph(strategies_max_3_comb_daily_rebal)
# Save all objects in the workspace to a file named 'my_workspace.RData'
save.image('my_workspace.RData')
# Load the objects from 'my_workspace.RData' into the workspace
# It's a good practice to start a new session or clear the workspace before loading the saved objects.
load('my_workspace.RData')
# Load the objects from 'my_workspace.RData' into the workspace
# It's a good practice to start a new session or clear the workspace before loading the saved objects.
load('my_workspace.RData')
# Load functions file
source("BDA_BDBD_functions - Luca.R")
# Set input parameters for function determine_optimal_strategy
your_df_return_series = index_daily_returns_CHF
your_time_horizon_years = 10
your_minimum_allowable_percentage = 0.75
View(index_daily_returns_CHF)
your_df_return_series = index_daily_returns_CHF
your_time_horizon_years = 10
your_minimum_allowable_percentage = 0.75
# Call function determine_optimal_strategy
# Note: function "determine_optimal_strategy" returns 4 objects: list(df_above_threshold, df_excluded, plot_list_different_periods_within_strategies, plot_lowest_cum_returns
# ----- COMPUTATIONALLY HEAVY -----
#
your_candidate_strategies_results <- determine_optimal_strategy(your_df_return_series, your_time_horizon_years, your_minimum_allowable_percentage)
your_strategies_above_threshold <- your_candidate_strategies_results[[1]]
your_strategies_below_threshold <- your_candidate_strategies_results[[2]]
your_plots_for_each_strategy <- your_candidate_strategies_results[[3]]
your_plot_lowest_returns_for_each_strategy <- your_candidate_strategies_results[[4]]
# your_strategies_above_threshold
# Print strategies that stayed above the threshold
print(paste("Strategies that stayed above the threshold:", nrow(your_strategies_above_threshold)))
print(your_strategies_above_threshold)
# your_strategies_below_threshold
# Print strategies that are refused for having decreased below the threshold
print(paste("Refused strategies (decreased below the threshold):", nrow(your_strategies_below_threshold)))
print(your_strategies_below_threshold)
specific_plot = your_plots_for_each_strategy[["US"]]
print(specific_plot)
print(specific_plot)
specific_plot = your_plots_for_each_strategy[["Europe"]]
print(specific_plot)
specific_plot = your_plots_for_each_strategy[["Gold bullion"]]
print(specific_plot)
# (2) If you would like to display multiple plots together, you can use the gridExtra package.
# You need to specify the plots you want to display as follows:
grid.arrange(
your_plots_for_each_strategy[["Europe"]],
your_plots_for_each_strategy[["Gold bullion"]],
ncol = 1  # Or any other number of columns you want
)
# your_plot_lowest_returns_for_each_strategy
# Plot the intermediate evolution of the lowest cumulative return series for each investment strategy (different colors for non-refused "group 1 strategies", and refused "group 2 strategies")
print(your_plot_lowest_returns_for_each_strategy)
### CPU optimisation ###
plan(multisession)  # use available cores for parallel processing
### CPU optimisation ###
plan(multisession)  # use available cores for parallel processing
