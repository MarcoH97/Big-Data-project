# [1] "Execution time:  1.8990490436554 seconds"
xts_strategies_max_2_comb_monthly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_monthly_returns_CHF,
max_comb_size = 2)
# [1] "Execution time:  1.95903587341309 seconds"
xts_strategies_max_2_comb_weekly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_weekly_returns_CHF,
max_comb_size = 2)
# [1] "Execution time:  3.07245182991028 seconds"
xts_strategies_max_2_comb_daily_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_daily_returns_CHF,
max_comb_size = 2)
# [1] "Execution time:  6.8100950717926 seconds"
## Max 3 combinations: yearly/quarterly/monthly/weekly/daily rebalancing
xts_strategies_max_3_comb_yearly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_yearly_returns_CHF,
max_comb_size = 3)
# [1] "Execution time:  162.96066904068 seconds"
xts_strategies_max_3_comb_quarterly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_quarterly_returns_CHF,
max_comb_size = 3)
# [1] "Execution time:  161.60431599617 seconds"
xts_strategies_max_3_comb_yearly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_yearly_returns_CHF,
max_comb_size = 3)
# [1] "Execution time:  154.727133989334 seconds"
xts_strategies_max_3_comb_yearly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_yearly_returns_CHF,
max_comb_size = 3)
# [1] "Execution time:  153.807525873184 seconds"
xts_strategies_max_3_comb_yearly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_yearly_returns_CHF,
max_comb_size = 3)
# [1] "Execution time:  153.25058722496 seconds"
xts_strategies_max_3_comb_monthly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_monthly_returns_CHF,
max_comb_size = 3)
gc()
## Max 3 combinations: yearly/quarterly/monthly/weekly/daily rebalancing
xts_strategies_max_3_comb_yearly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_yearly_returns_CHF,
max_comb_size = 3)
# [1] "Execution time:  156.129092931747 seconds"
xts_strategies_max_3_comb_quarterly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_quarterly_returns_CHF,
max_comb_size = 3)
# [1] "Execution time:  161.208724021912 seconds"
xts_strategies_max_3_comb_monthly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_monthly_returns_CHF,
max_comb_size = 3)
# [1] "Execution time:   seconds"
xts_strategies_max_3_comb_weekly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_weekly_returns_CHF,
max_comb_size = 3)
# [1] "Execution time:   seconds"
xts_strategies_max_3_comb_daily_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_daily_returns_CHF,
max_comb_size = 3)
# [1] "Execution time:   seconds"
xts_strategies_max_2_comb_yearly_rebal
# Define a function that generates columns of equally-weighted indices, with daily rebalancing
generate_weighted_cols_daily_rebal <- function(index_returns, max_comb_size) {
# Start timer to later display how long the function took to run
start_time <- Sys.time()
# Create a dataframe that contains the initial investment strategies (investing 100% in an index), without the Dates column
investment_strategies <- index_returns[, -1]
# Get the number of columns (indices) in the dataframe
num_cols <- ncol(investment_strategies)
# Iterate over i for i-combinations
for (i in 2:min(num_cols, max_comb_size)) {
# Generate all i-combinations of column indices
combos <- combinat::combn(1:num_cols, i, simplify = FALSE)
# Iterate over each combination
for (combo in combos) {
# Calculate the new column as the row-wise mean of the selected columns
new_col <- rowMeans(investment_strategies[, combo])
# Create the new column name
new_col_name <- paste(names(investment_strategies)[combo], collapse = " & ")
# Add the new column to the dataframe
index_returns[[new_col_name]] <- new_col
}
}
# Display how long the function took to run
end_time <- Sys.time()
execution_time <- as.numeric(end_time - start_time, units = "secs")
print(paste("Execution time: ", execution_time, "seconds"))
return(index_returns)
}
# Define a function that generates columns of equally-weighted indices, with periodic rebalancing
xts_generate_weighted_cols <- function(xts_return_series, max_comb_size) {
# Start timer to later display how long the function took to run
start_time <- Sys.time()
# Replace "-" by "_" in column names
names(xts_return_series) <- gsub("-", "_", names(xts_return_series))
# Create an xts object that contains the initial investment strategies (investing 100% in an index)
investment_strategies <- xts_return_series
# Get the number of columns (indices) in the dataframe
num_cols <- ncol(investment_strategies)
# Iterate over i for i-combinations
for (i in 2:min(num_cols, max_comb_size)) {
# Generate all i-combinations of column indices
combos <- combinat::combn(1:num_cols, i, simplify = FALSE)
# Iterate over each combination
for (combo in combos) {
# Calculate the new column as the row-wise mean of the selected columns
new_col <- rowMeans(investment_strategies[, combo])
# Convert new_col to xts
new_col_xts <- xts(new_col, order.by=index(xts_return_series))
# Create the new column name
new_col_name <- paste(names(investment_strategies)[combo], collapse = " & ")
colnames(new_col_xts) <- new_col_name
# Add the new column to the xts object
xts_return_series <- merge(xts_return_series, new_col_xts)
}
}
# Replace "...." by " & " and "." by " " in column names
names(xts_return_series) <- gsub("\\.\\.\\.\\.", " & ", names(xts_return_series))
names(xts_return_series) <- gsub("\\.", " ", names(xts_return_series))
# Display how long the function took to run
end_time <- Sys.time()
execution_time <- as.numeric(end_time - start_time, units = "secs")
print(paste("Execution time: ", execution_time, "seconds"))
return(xts_return_series)
}
# Load functions file
source("BDA_BDBD_functions - Luca.R")
# Inspect the size of the generated dataframes that contain the different investment strategies
print(paste("strategies_max_2_comb_daily_rebal (generated):", round(object.size(strategies_max_2_comb_daily_rebal) / 1048576, 2), "MB"))
print(paste("strategies_max_3_comb_daily_rebal (generated):", round(object.size(strategies_max_3_comb_daily_rebal) / 1048576, 2), "MB"))
print(paste("strategies_max_4_comb_daily_rebal (generated):", round(object.size(strategies_max_4_comb_daily_rebal) / 1048576, 2), "MB"))
# Inspect the size of the generated xts objects that contain the different investment strategies
print(paste("xts_strategies_max_2_comb_yearly_rebal (generated):", round(object.size(xts_strategies_max_2_comb_yearly_rebal) / 1048576, 2), "MB"))
print(paste("xts_strategies_max_2_comb_quarterly_rebal (generated):", round(object.size(xts_strategies_max_2_comb_quarterly_rebal) / 1048576, 2), "MB"))
print(paste("xts_strategies_max_2_comb_monthly_rebal (generated):", round(object.size(xts_strategies_max_2_comb_monthly_rebal) / 1048576, 2), "MB"))
print(paste("xts_strategies_max_2_comb_weekly_rebal (generated):", round(object.size(xts_strategies_max_2_comb_weekly_rebal) / 1048576, 2), "MB"))
print(paste("xts_strategies_max_2_comb_daily_rebal (generated):", round(object.size(xts_strategies_max_2_comb_daily_rebal) / 1048576, 2), "MB"))
print(paste("xts_strategies_max_3_comb_yearly_rebal (generated):", round(object.size(xts_strategies_max_3_comb_yearly_rebal) / 1048576, 2), "MB"))
print(paste("xts_strategies_max_3_comb_quarterly_rebal (generated):", round(object.size(xts_strategies_max_3_comb_quarterly_rebal) / 1048576, 2), "MB"))
print(paste("xts_strategies_max_3_comb_monthly_rebal (generated):", round(object.size(xts_strategies_max_3_comb_monthly_rebal) / 1048576, 2), "MB"))
print(paste("xts_strategies_max_3_comb_weekly_rebal (generated):", round(object.size(xts_strategies_max_3_comb_weekly_rebal) / 1048576, 2), "MB"))
print(paste("xts_strategies_max_3_comb_daily_rebal (generated):", round(object.size(xts_strategies_max_3_comb_daily_rebal) / 1048576, 2), "MB"))
# Plot the correlation matrix between returns of the initial 26 indices
plot_correlation_matrix(index_daily_returns_CHF)
# Plot the mean-variance graph for daily returns of each investment strategy in the data frame (first column is "Dates")
# First for only the 26 initial variables, than for all combinations up to 2, than for all higher number of combinations.
plot_mean_variance_graph(index_daily_returns_CHF)
plot_mean_variance_graph(strategies_max_2_comb_daily_rebal)
plot_mean_variance_graph(strategies_max_3_comb_daily_rebal)
plot_mean_variance_graph(strategies_max_4_comb_daily_rebal)
# Save all objects in the workspace to a file named 'my_workspace.RData'
save.image('all_data_max_4_comb.RData')
# Load functions file
source("BDA_BDBD_functions - Luca.R")
xts_results_simplified_optimal_strategy_max_2_comb_yearly_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_2_comb_yearly_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "yearly")
xts_results_simplified_optimal_strategy_max_2_comb_quarterly_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_2_comb_quarterly_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "quarterly")
yearly
xts_return_series = xts_strategies_max_2_comb_quarterly_rebal
time_horizon_years = 12
xts_strategies_max_2_comb_yearly_rebal
xts_return_series = xts_index_yearly_returns_CHF
time_horizon_years = 12
minimum_allowable_percentage = 0.75
granularity = "yearly"
# Initialize constants and variables
granularity <- tolower(granularity)
periods_per_year <- switch(granularity,
"daily" = 252,
"weekly" = 52,
"monthly" = 12,
"quarterly" = 4,
"yearly" = 1,
stop("Invalid granularity"))
periods_per_year
time_horizon_periods <- time_horizon_years * periods_per_year
# Initialize data frames to store results
df_above_threshold <- data.frame(Strategy = character(), LowestCumulativeReturn = numeric())
df_refused <- data.frame(Strategy = character())
# Main loop over each strategy
for (col in names(xts_return_series)) {
# Initialization of variables for current strategy
lowest_cumulative_return <- Inf
highest_cumulative_return <- -Inf
lowest_cumulative_series <- NULL
highest_cumulative_series <- NULL
exclude <- FALSE
# Loop over all possible starting times for the specified time horizon
for (i in seq(1, (nrow(xts_return_series) - time_horizon_periods))) {
# Compute cumulative returns for the current time period
cum_returns_time_period <- cumprod(1 + xts_return_series[i:(i + time_horizon_periods - 1), col])
# Check if the minimum cumulative return is below the threshold.
# If so, exclude the strategy, add it to df_refused and break out of the current loop
if (any(cum_returns_time_period < minimum_allowable_percentage)) {
exclude <- TRUE
df_refused <- rbind(df_refused, data.frame(Strategy = col))
break
}
# Keep track of the lowest cumulative return for the current strategy
if (as.numeric(last(cum_returns_time_period))  < lowest_cumulative_return) {
lowest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
}
# Keep track of the highest cumulative return for the current strategy
if (as.numeric(last(cum_returns_time_period)) > highest_cumulative_return) {
highest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
}
}
# If the strategy is not marked for exclusion add to df_above_threshold
if (exclude == FALSE) {
df_above_threshold <- rbind(df_above_threshold,
data.frame(Strategy = col,
LowestCumulativeReturn = as.numeric(coredata(last(lowest_cumulative_return))),
HighestCumulativeReturn = as.numeric(coredata(last(highest_cumulative_return)))))
}
}
# Select the optimal strategy as the one with the highest minimum cumulative return that didn't fall below the threshold
optimal_strategy <- df_above_threshold[which.max(df_above_threshold$LowestCumulativeReturn), "Strategy"]
optimal_strategy
df_above_threshold
df_refused
total_function_time_0
xts_return_series = xts_index_quarterly_returns_CHF
granularity = "quarterly"
# Initialize constants and variables
granularity <- tolower(granularity)
periods_per_year <- switch(granularity,
"daily" = 252,
"weekly" = 52,
"monthly" = 12,
"quarterly" = 4,
"yearly" = 1,
stop("Invalid granularity"))
periods_per_year
time_horizon_periods <- time_horizon_years * periods_per_year
time_horizon_periods
# Initialize data frames to store results
df_above_threshold <- data.frame(Strategy = character(), LowestCumulativeReturn = numeric())
df_refused <- data.frame(Strategy = character())
names(xts_return_series)
# Main loop over each strategy
for (col in names(xts_return_series)) {
# Initialization of variables for current strategy
lowest_cumulative_return <- Inf
highest_cumulative_return <- -Inf
lowest_cumulative_series <- NULL
highest_cumulative_series <- NULL
exclude <- FALSE
# Loop over all possible starting times for the specified time horizon
for (i in seq(1, (nrow(xts_return_series) - time_horizon_periods))) {
# Compute cumulative returns for the current time period
cum_returns_time_period <- cumprod(1 + xts_return_series[i:(i + time_horizon_periods - 1), col])
# Check if the minimum cumulative return is below the threshold.
# If so, exclude the strategy, add it to df_refused and break out of the current loop
if (any(cum_returns_time_period < minimum_allowable_percentage)) {
exclude <- TRUE
df_refused <- rbind(df_refused, data.frame(Strategy = col))
break
}
# Keep track of the lowest cumulative return for the current strategy
if (as.numeric(last(cum_returns_time_period))  < lowest_cumulative_return) {
lowest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
}
# Keep track of the highest cumulative return for the current strategy
if (as.numeric(last(cum_returns_time_period)) > highest_cumulative_return) {
highest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
}
}
# If the strategy is not marked for exclusion add to df_above_threshold
if (exclude == FALSE) {
df_above_threshold <- rbind(df_above_threshold,
data.frame(Strategy = col,
LowestCumulativeReturn = as.numeric(coredata(last(lowest_cumulative_return))),
HighestCumulativeReturn = as.numeric(coredata(last(highest_cumulative_return)))))
}
}
# Select the optimal strategy as the one with the highest minimum cumulative return that didn't fall below the threshold
optimal_strategy <- df_above_threshold[which.max(df_above_threshold$LowestCumulativeReturn), "Strategy"]
optimal_strategy
df_above_threshold
df_refused
xts_return_series = xts_index_monthly_returns_CHF
granularity = "monthly"
# Start timer for performance tracking
total_function_start_0 <- Sys.time()
# Initialize constants and variables
granularity <- tolower(granularity)
periods_per_year <- switch(granularity,
"daily" = 252,
"weekly" = 52,
"monthly" = 12,
"quarterly" = 4,
"yearly" = 1,
stop("Invalid granularity"))
time_horizon_periods <- time_horizon_years * periods_per_year
# Initialize data frames to store results
df_above_threshold <- data.frame(Strategy = character(), LowestCumulativeReturn = numeric())
df_refused <- data.frame(Strategy = character())
# Main loop over each strategy
for (col in names(xts_return_series)) {
# Initialization of variables for current strategy
lowest_cumulative_return <- Inf
highest_cumulative_return <- -Inf
lowest_cumulative_series <- NULL
highest_cumulative_series <- NULL
exclude <- FALSE
# Loop over all possible starting times for the specified time horizon
for (i in seq(1, (nrow(xts_return_series) - time_horizon_periods))) {
# Compute cumulative returns for the current time period
cum_returns_time_period <- cumprod(1 + xts_return_series[i:(i + time_horizon_periods - 1), col])
# Check if the minimum cumulative return is below the threshold.
# If so, exclude the strategy, add it to df_refused and break out of the current loop
if (any(cum_returns_time_period < minimum_allowable_percentage)) {
exclude <- TRUE
df_refused <- rbind(df_refused, data.frame(Strategy = col))
break
}
# Keep track of the lowest cumulative return for the current strategy
if (as.numeric(last(cum_returns_time_period))  < lowest_cumulative_return) {
lowest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
}
# Keep track of the highest cumulative return for the current strategy
if (as.numeric(last(cum_returns_time_period)) > highest_cumulative_return) {
highest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
}
}
# If the strategy is not marked for exclusion add to df_above_threshold
if (exclude == FALSE) {
df_above_threshold <- rbind(df_above_threshold,
data.frame(Strategy = col,
LowestCumulativeReturn = as.numeric(coredata(last(lowest_cumulative_return))),
HighestCumulativeReturn = as.numeric(coredata(last(highest_cumulative_return)))))
}
}
# Select the optimal strategy as the one with the highest minimum cumulative return that didn't fall below the threshold
optimal_strategy <- df_above_threshold[which.max(df_above_threshold$LowestCumulativeReturn), "Strategy"]
# Compute and print the total execution time of the function
total_function_end_0 <- Sys.time()
total_function_time_0 <- as.numeric(total_function_end_0 - total_function_start_0, units = "secs")
print(paste("Execution time for FUNCTION determine_optimal_strategy_simplified, DATASET", deparse(substitute(df_return_series)), ", GRANULARITY", granularity, ":", round(total_function_time_0, 2), "seconds"))
optimal_strategy
df_above_threshold
df_refused
granularity = "weekly"
xts_return_series = xts_index_weekly_returns_CHF
# Start timer for performance tracking
total_function_start_0 <- Sys.time()
# Initialize constants and variables
granularity <- tolower(granularity)
periods_per_year <- switch(granularity,
"daily" = 252,
"weekly" = 52,
"monthly" = 12,
"quarterly" = 4,
"yearly" = 1,
stop("Invalid granularity"))
time_horizon_periods <- time_horizon_years * periods_per_year
# Initialize data frames to store results
df_above_threshold <- data.frame(Strategy = character(), LowestCumulativeReturn = numeric())
df_refused <- data.frame(Strategy = character())
# Main loop over each strategy
for (col in names(xts_return_series)) {
# Initialization of variables for current strategy
lowest_cumulative_return <- Inf
highest_cumulative_return <- -Inf
lowest_cumulative_series <- NULL
highest_cumulative_series <- NULL
exclude <- FALSE
# Loop over all possible starting times for the specified time horizon
for (i in seq(1, (nrow(xts_return_series) - time_horizon_periods))) {
# Compute cumulative returns for the current time period
cum_returns_time_period <- cumprod(1 + xts_return_series[i:(i + time_horizon_periods - 1), col])
# Check if the minimum cumulative return is below the threshold.
# If so, exclude the strategy, add it to df_refused and break out of the current loop
if (any(cum_returns_time_period < minimum_allowable_percentage)) {
exclude <- TRUE
df_refused <- rbind(df_refused, data.frame(Strategy = col))
break
}
# Keep track of the lowest cumulative return for the current strategy
if (as.numeric(last(cum_returns_time_period))  < lowest_cumulative_return) {
lowest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
}
# Keep track of the highest cumulative return for the current strategy
if (as.numeric(last(cum_returns_time_period)) > highest_cumulative_return) {
highest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
}
}
# If the strategy is not marked for exclusion add to df_above_threshold
if (exclude == FALSE) {
df_above_threshold <- rbind(df_above_threshold,
data.frame(Strategy = col,
LowestCumulativeReturn = as.numeric(coredata(last(lowest_cumulative_return))),
HighestCumulativeReturn = as.numeric(coredata(last(highest_cumulative_return)))))
}
}
# Select the optimal strategy as the one with the highest minimum cumulative return that didn't fall below the threshold
optimal_strategy <- df_above_threshold[which.max(df_above_threshold$LowestCumulativeReturn), "Strategy"]
# Compute and print the total execution time of the function
total_function_end_0 <- Sys.time()
total_function_time_0 <- as.numeric(total_function_end_0 - total_function_start_0, units = "secs")
print(paste("Execution time for FUNCTION xts_determine_optimal_strategy_simplified, DATASET", deparse(substitute(df_return_series)), ", GRANULARITY", granularity, ":", round(total_function_time_0, 2), "seconds"))
optimal_strategy
df_above_threshold
xts_determine_optimal_strategy_simplified <- function(xts_return_series = xts_index_yearly_returns_CHF,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "yearly") {
# Start timer for performance tracking
total_function_start_0 <- Sys.time()
# Initialize constants and variables
granularity <- tolower(granularity)
periods_per_year <- switch(granularity,
"daily" = 252,
"weekly" = 52,
"monthly" = 12,
"quarterly" = 4,
"yearly" = 1,
stop("Invalid granularity"))
time_horizon_periods <- time_horizon_years * periods_per_year
# Initialize data frames to store results
df_above_threshold <- data.frame(Strategy = character(), LowestCumulativeReturn = numeric())
df_refused <- data.frame(Strategy = character())
# Main loop over each strategy
for (col in names(xts_return_series)) {
# Initialization of variables for current strategy
lowest_cumulative_return <- Inf
highest_cumulative_return <- -Inf
lowest_cumulative_series <- NULL
highest_cumulative_series <- NULL
exclude <- FALSE
# Loop over all possible starting times for the specified time horizon
for (i in seq(1, (nrow(xts_return_series) - time_horizon_periods))) {
# Compute cumulative returns for the current time period
cum_returns_time_period <- cumprod(1 + xts_return_series[i:(i + time_horizon_periods - 1), col])
# Check if the minimum cumulative return is below the threshold.
# If so, exclude the strategy, add it to df_refused and break out of the current loop
if (any(cum_returns_time_period < minimum_allowable_percentage)) {
exclude <- TRUE
df_refused <- rbind(df_refused, data.frame(Strategy = col))
break
}
# Keep track of the lowest cumulative return for the current strategy
if (as.numeric(last(cum_returns_time_period))  < lowest_cumulative_return) {
lowest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
}
# Keep track of the highest cumulative return for the current strategy
if (as.numeric(last(cum_returns_time_period)) > highest_cumulative_return) {
highest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
}
}
# If the strategy is not marked for exclusion add to df_above_threshold
if (exclude == FALSE) {
df_above_threshold <- rbind(df_above_threshold,
data.frame(Strategy = col,
LowestCumulativeReturn = as.numeric(coredata(last(lowest_cumulative_return))),
HighestCumulativeReturn = as.numeric(coredata(last(highest_cumulative_return)))))
}
}
# Select the optimal strategy as the one with the highest minimum cumulative return that didn't fall below the threshold
optimal_strategy <- df_above_threshold[which.max(df_above_threshold$LowestCumulativeReturn), "Strategy"]
# Compute and print the total execution time of the function
total_function_end_0 <- Sys.time()
total_function_time_0 <- as.numeric(total_function_end_0 - total_function_start_0, units = "secs")
print(paste("Execution time for FUNCTION xts_determine_optimal_strategy_simplified, DATASET", deparse(substitute(df_return_series)), ", GRANULARITY", granularity, ":", round(total_function_time_0, 2), "seconds"))
# Return a list with the optimal strategy, two data frames for the strategies above threshold and refused, and the total execution time of the function
return(list(optimal_strategy, df_above_threshold, df_refused, total_function_time_0))
}
gc()
xts_results_simplified_optimal_strategy_max_2_comb_yearly_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_2_comb_yearly_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "yearly")
xts_results_simplified_optimal_strategy_max_2_comb_quarterly_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_2_comb_quarterly_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "quarterly")
xts_results_simplified_optimal_strategy_max_2_comb_weekly_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_2_comb_weekly_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "weekly")
xts_results_simplified_optimal_strategy_max_2_comb_daily_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_2_comb_daily_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "daily")
# Define a function that generates columns of equally-weighted indices, with periodic rebalancing
xts_generate_weighted_cols <- function(xts_return_series, max_comb_size) {
# Start timer to later display how long the function took to run
start_time <- Sys.time()
# Replace "-" by "_" in column names
names(xts_return_series) <- gsub("-", "_", names(xts_return_series))
# Create an xts object that contains the initial investment strategies (investing 100% in an index)
investment_strategies <- xts_return_series
# Get the number of columns (indices) in the dataframe
num_cols <- ncol(investment_strategies)
# Iterate over i for i-combinations
for (i in 2:min(num_cols, max_comb_size)) {
# Generate all i-combinations of column indices
combos <- combinat::combn(1:num_cols, i, simplify = FALSE)
# Iterate over each combination
for (combo in combos) {
# Calculate the new column as the row-wise mean of the selected columns
new_col <- rowMeans(investment_strategies[, combo])
# Convert new_col to xts
new_col_xts <- xts(new_col, order.by=index(xts_return_series))
# Create the new column name
new_col_name <- paste(names(investment_strategies)[combo], collapse = " & ")
colnames(new_col_xts) <- new_col_name
# Add the new column to the xts object
xts_return_series <- merge(xts_return_series, new_col_xts)
}
}
# # Replace "...." by " & " and "." by " " in column names
# names(xts_return_series) <- gsub("\\.\\.\\.\\.", " & ", names(xts_return_series))
# names(xts_return_series) <- gsub("\\.", " ", names(xts_return_series))
# Display how long the function took to run
end_time <- Sys.time()
execution_time <- as.numeric(end_time - start_time, units = "secs")
print(paste("Execution time: ", execution_time, "seconds"))
return(xts_return_series)
}
xts_strategies_max_2_comb_daily_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_daily_returns_CHF,
max_comb_size = 2)
