print(paste("CHF_FX:", round(object.size(CHF_FX) / 1048576, 2), "MB"))
print(paste("CHF_rf_rates:", round(object.size(CHF_rf_rates) / 1048576, 2), "MB"))
print(paste("swiss_inflation:", round(object.size(swiss_inflation) / 1048576, 2), "MB"))
##############################################################################
# DATA CLEANING AND DATA INTEGRATION
# Inspect classes of the  Dates columns of the different data frames
class(index_prices_local_currency$Dates)
class(CHF_FX$Dates)
class(swiss_inflation$Dates)
class(CHF_rf_rates$Dates)
# Convert Dates to a Date object
index_prices_local_currency$Dates <- as.Date(index_prices_local_currency$Dates)
CHF_FX$Dates <- as.Date(CHF_FX$Dates)
CHF_rf_rates$Dates <- as.Date(CHF_rf_rates$Dates)
swiss_inflation$Dates <- as.Date(paste(swiss_inflation$Dates, "-01-01", sep = ""), format = "%Y-%m-%d")
# Sort the data frames by the 'Dates' column in descending order (from most recent to older)
index_prices_local_currency <- index_prices_local_currency[order(index_prices_local_currency$Dates, decreasing = TRUE),]
CHF_FX <- CHF_FX[order(CHF_FX$Dates, decreasing = TRUE),]
swiss_inflation <- swiss_inflation[order(swiss_inflation$Dates, decreasing = TRUE),]
CHF_rf_rates <- CHF_rf_rates[order(CHF_rf_rates$Dates, decreasing = TRUE),]
# Change the column name for Swiss inflation (CPI in %) and convert the data to actual percentages
if (names(swiss_inflation)[2] == "Switzerland") {
names(swiss_inflation)[2] <- "Swiss inflation (CPI)"
swiss_inflation$"Swiss inflation (CPI)" <- as.numeric(swiss_inflation$"Swiss inflation (CPI)") / 100
}
# Convert "#N/A N/A" to NA (in character or factor columns only)
is_char_or_factor <- sapply(index_prices_local_currency, function(col) is.character(col) | is.factor(col))
index_prices_local_currency[is_char_or_factor] <- lapply(index_prices_local_currency[is_char_or_factor], function(col) {
ifelse(col == "#N/A N/A", NA, col)
})
is_char_or_factor <- sapply(CHF_FX, function(col) is.character(col) | is.factor(col))
CHF_FX[is_char_or_factor] <- lapply(CHF_FX[is_char_or_factor], function(col) {
ifelse(col == "#N/A N/A", NA, col)
})
# Determine indices that do not contain sufficiently long dated price data and are not essential to the investment universe
index_prices_local_currency_NA_dates <- determine_start_dates(index_prices_local_currency)
print(index_prices_local_currency_NA_dates)
# Remove indices (columns) that do not contain sufficiently long dated price data and are not essential to the investment universe
# --> removing mid cap equity indices (insufficiently long dated price data for Switzerland, remove the corresponding index for other geographies, and total stock market index already covers large- and mid-cap equity)
# --> removing large cap equity indices (total stock market index already covers large- and mid-cap equity)
# --> removing real estate index (insufficiently long dated price data)
# --> removing 2 duplicates of I08240CH
index_prices_local_currency <- index_prices_local_currency[, !(colnames(index_prices_local_currency) %in% c("MXCHMC Index", "MXEUMC Index", "MXUSMC Index", "MXEFMC Index", "MXWOMC Index",
"MXUSLC Index", "MXEULC Index", "MXEFLC Index", "MXCHLC Index", "MXWOLC Index",
"TENHGU Index",
"I08240 Index", "I08240EU Index"))]
# Determine currency pairs that do not contain sufficiently long dated price data and are not essential to the investment universe
CHF_FX_NA_dates <- determine_start_dates(CHF_FX)
print(CHF_FX_NA_dates)
# Remove currency pairs (columns) that do not contain sufficiently long dated price data and are not essential to the investment universe
# NOT APPLICABLE
# Provide better names to remaining columns of dataframes index_prices_local_currency and CHF_FX
index_prices_local_currency <- rename_columns(index_prices_local_currency)
CHF_FX <- rename_columns(CHF_FX)
# Transform non-NA values from character to numeric
index_prices_local_currency <- index_prices_local_currency %>%
mutate_at(
vars(-Dates),
~as.numeric(na_if(., ""))  # Convert non-empty strings to numeric
)
CHF_FX <- CHF_FX %>%
mutate_at(
vars(-Dates),
~as.numeric(na_if(., ""))  # Convert non-empty strings to numeric
)
# For each geography, combine the three intermediate-term treasuries (3-5Y, 5-7Y, 7-10Y) into one investable security that is weighted 1/3 in each
index_prices_local_currency <- index_prices_local_currency %>%
mutate(`US IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`US IT treasuries 3-5Y` + `US IT treasuries 5-7Y` + `US IT treasuries 7-10Y`) / 3,
`Europe IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`Europe IT treasuries 3-5Y` + `Europe IT treasuries 5-7Y` + `Europe IT treasuries 7-10Y`) / 3,
`EM IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`EM IT treasuries 3-5Y` + `EM IT treasuries 5-7Y` + `EM IT treasuries 7-10Y`) / 3,
`Switzerland IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`Switzerland IT treasuries 3-5Y` + `Switzerland IT treasuries 5-7Y` + `Switzerland IT treasuries 7-10Y`) / 3,
`World IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`World IT treasuries 3-5Y` + `World IT treasuries 5-7Y` + `World IT treasuries 7-10Y`) / 3)
# Remove the original intermediate-term treasuries columns
index_prices_local_currency <- index_prices_local_currency %>%
select(-ends_with("3-5Y"), -ends_with("5-7Y"), -ends_with("7-10Y"))
# Rearrange the indices (columns) to a more logical order
index_prices_local_currency <- rearrange_columns(index_prices_local_currency)
# Remove longer dated observations until each column contains values for each remaining date (row)
# i.e. Filter the data frames to include only rows starting from the latest start date
index_prices_local_currency <- filter(index_prices_local_currency,
Dates > max(determine_start_dates(index_prices_local_currency)))
CHF_FX <- filter(CHF_FX,
Dates >= max(determine_start_dates(index_prices_local_currency)))
CHF_rf_rates <- filter(CHF_rf_rates,
Dates >= max(determine_start_dates(index_prices_local_currency)))
# Generate dataframe containing index prices in CHF (calculated from index_prices_local_currency and CHF_FX)
# Initialize dataframe that will contain index prices in CHF
index_prices_CHF <- index_prices_local_currency
# Select the columns representing USD, EUR, and CHF denominated indexes
usd_indexes <- c("US", "US small cap", "Europe small cap", "EM", "EM small cap", "Switzerland small cap", "World", "World small cap", "US ST treasuries 1-3Y", "US IT treasuries (3-5Y, 5-7Y, 7-10Y)", "US LT treasuries 10Y+", "EM ST treasuries 1-3Y", "EM IT treasuries (3-5Y, 5-7Y, 7-10Y)", "EM LT treasuries 10Y+", "World ST treasuries 1-3Y", "World IT treasuries (3-5Y, 5-7Y, 7-10Y)", "World LT treasuries 10Y+", "Gold bullion")
eur_indexes <- c("Europe", "Europe ST treasuries 1-3Y", "Europe IT treasuries (3-5Y, 5-7Y, 7-10Y)", "Europe LT treasuries 10Y+")
chf_indexes <- c("Switzerland", "Switzerland ST treasuries 1-3Y", "Switzerland IT treasuries (3-5Y, 5-7Y, 7-10Y)", "Switzerland LT treasuries 10Y+")
# Multiply USD denominated columns by CHF/USD exchange rate
index_prices_CHF[, usd_indexes] <- index_prices_CHF[, usd_indexes] * CHF_FX[["CHF per USD"]]
# Multiply EUR denominated columns by CHF/EUR exchange rate
index_prices_CHF[, eur_indexes] <- index_prices_CHF[, eur_indexes] * CHF_FX[["CHF per EUR"]]
# Inspect dataframe index_prices_CHF
print(index_prices_CHF)
colnames(index_prices_CHF)
head(index_prices_CHF, 10)
tail(index_prices_CHF, 10)
# Generate dataframe containing daily price returns in CHF (calculated from index_prices_CHF)
# Initialize dataframe that will contain daily price returns in CHF
index_daily_returns_CHF <- data.frame(index_prices_CHF$Dates)
names(index_daily_returns_CHF)[1] <- "Dates"
# Calculate daily price returns for each index in CHF
num_rows <- nrow(index_prices_CHF)
for (col in colnames(index_prices_CHF)[-1]) {
prices <- index_prices_CHF[[col]]
returns <- (prices[1:(num_rows - 1)] / prices[2:num_rows]) - 1
index_daily_returns_CHF[[col]] <- c(returns, NA)
}
index_daily_returns_CHF <- na.omit(index_daily_returns_CHF) # This removes the final row, which only contains returns of value NA
# Inspect the size of the cleaned data that we continue from
print(paste("index_daily_returns_CHF:", round(object.size(index_daily_returns_CHF) / 1048576, 2), "MB"))
print(paste("CHF_FX:", round(object.size(CHF_FX) / 1048576, 2), "MB"))
print(paste("CHF_rf_rates:", round(object.size(CHF_rf_rates) / 1048576, 2), "MB"))
print(paste("swiss_inflation:", round(object.size(swiss_inflation) / 1048576, 2), "MB"))
##############################################################################
# DATA PREPARATION
# Feature engineering a large set of investment strategies (as separate columns). Strategies differ in:
# (a) their strategic asset allocation, i.e. different (equally-weighted) combinations of the 26 index return series.
# (b) their rebalancing technique: periodic (e.g., daily/monthly/quarterly-semi-annually/annually) or threshold-based (e.g., 10%/20%/25% deviation from original weight)
# Notice that, as we increase the number of combinations that we implement, the number of additional columns increases exponentially.
# Generating new columns (different investment strategies) from our daily index returns in CHF
# Define a function that generates columns of equally-weighted indices, with daily rebalancing
generate_weighted_cols <- function(index_returns, max_comb_size) {
# Start timer to later display how long the function took to run
start_time <- Sys.time()
# Create a dataframe that contains the initial investment strategies (investing 100% in an index), without the Dates column
investment_strategies <- index_returns[, -1]
# Get the number of columns (indices) in the dataframe
num_cols <- ncol(investment_strategies)
# Iterate over i for i-combinations
for (i in 2:min(num_cols, max_comb_size)) {
# Generate all i-combinations of column indices
combos <- combinat::combn(1:num_cols, i, simplify = FALSE)
# Iterate over each combination
for (combo in combos) {
# Calculate the new column as the row-wise mean of the selected columns
new_col <- rowMeans(investment_strategies[, combo])
# Create the new column name
new_col_name <- paste(names(investment_strategies)[combo], collapse = " ")
# Add the new column to the dataframe
index_returns[[new_col_name]] <- new_col
}
}
# Display how long the function took to run
end_time <- Sys.time()
execution_time <- as.numeric(end_time - start_time, units = "secs")
print(paste("Execution time: ", execution_time, "seconds"))
return(index_returns)
}
# Generate columns of equally-weighted indices, with daily rebalancing
strategies_max_2_comb_daily_rebal <- generate_weighted_cols(index_daily_returns_CHF, 2)
strategies_max_3_comb_daily_rebal <- generate_weighted_cols(index_daily_returns_CHF, 3)
strategies_max_4_comb_daily_rebal <- generate_weighted_cols(index_daily_returns_CHF, 4)
# Combine all candidate investment strategies (including the separate initial indices) into one data frame "all_candidate_strategies_max_4_comb"
all_candidate_strategies_max_4_comb_list <- list(index_daily_returns_CHF, strategies_max_2_comb_daily_rebal,
strategies_max_3_comb_daily_rebal, strategies_max_4_comb_daily_rebal)
all_candidate_strategies_max_4_comb <- Reduce(function(x, y) merge(x, y, by = "Dates", all = TRUE), all_candidate_strategies_max_4_comb_list)
# Inspect the merged dataframe
print(merged_df)
# Inspect the merged dataframe
print(all_candidate_strategies_max_4_comb)
head(all_candidate_strategies_max_4_comb, 10)
head(all_candidate_strategies_max_4_comb, 3)
strategies_max_2_comb_daily_rebal
strategies_max_3_comb_daily_rebal
strategies_max_4_comb_daily_rebal
all_candidate_strategies_max_4_comb_list
all_candidate_strategies_max_4_comb
# Inspect the size of the generated data that contains the different investment strategies
print(paste("strategies_max_2_comb_daily_rebal (generated):", round(object.size(strategies_max_2_comb_daily_rebal) / 1048576, 2), "MB"))
print(paste("strategies_max_3_comb_daily_rebal (generated):", round(object.size(strategies_max_3_comb_daily_rebal) / 1048576, 2), "MB"))
print(paste("strategies_max_4_comb_daily_rebal (generated):", round(object.size(strategies_max_4_comb_daily_rebal) / 1048576, 2), "MB"))
print(paste("all_candidate_strategies_max_4_comb (generated):", round(object.size(all_candidate_strategies_max_4_comb) / 1048576, 2), "MB"))
head(all_candidate_strategies_max_4_comb[,1], 3)
head(all_candidate_strategies_max_4_comb[1,], 3)
# Inspect a subset of the merged dataframe
head(all_candidate_strategies_max_4_comb[, 1:30], 5)
# Inspect a subset of the merged dataframe
head(all_candidate_strategies_max_4_comb[, 1:30], 5)
# Merge all candidate investment strategies (including the separate initial indices) into one data frame "all_candidate_strategies_max_4_comb"
all_strategies_upto_4_comb_daily_rebal_list <- list(index_daily_returns_CHF, strategies_max_2_comb_daily_rebal,
strategies_max_3_comb_daily_rebal, strategies_max_4_comb_daily_rebal)
all_strategies_upto_4_comb_daily_rebal <- Reduce(function(x, y) merge(x, y, by = "Dates", all = TRUE), all_candidate_strategies_max_4_comb_list)
# Assisted by ChatGPT (https://chat.openai.com/) while writing the code below.
# Load packages
library(combinat)
library(foreach)
library(doParallel)
library(readxl)
library(progress)
library(dplyr)
library(parallel)
library(future.apply)
library(progressr)
library(RSQLite)
library(DBI)
library(ggplot2)
library(reshape2)
library(scales)
##############################################################################
# Get the directory path of the current code file
PATH <- dirname(rstudioapi::getSourceEditorContext()$path)
# Set the working directory to that of the current code file
setwd(PATH)
# Load functions file
source("BDA_BDBD_functions - Luca.R")
##############################################################################
# DATA COLLECTION: leveraging data from multiple sources
# Loading the raw data into R from different sources, each with different data formats.
# Load raw data for prices of selected indices
data_indices_full <- read_excel("Bloomberg_Terminal-spreadsheet_builder.xlsx", sheet = 1, col_names = FALSE)
index_prices_local_currency <- data_indices_full[7:nrow(data_indices_full), ]
colnames(index_prices_local_currency) <- data_indices_full[4, ]
names(index_prices_local_currency)[1] <- "Dates"
index_prices_local_currency$Dates <- as.Date(as.numeric(index_prices_local_currency$Dates), origin = "1899-12-30")
# Load raw data for prices of selected indices
data_FX_full <- read_excel("Bloomberg_Terminal-spreadsheet_builder.xlsx", sheet = 2, col_names = FALSE)
CHF_FX <- data_FX_full[7:nrow(data_indices_full), ]
colnames(CHF_FX) <- data_FX_full[4, ]
names(CHF_FX)[1] <- "Dates"
CHF_FX$Dates <- as.Date(as.numeric(CHF_FX$Dates), origin = "1899-12-30")
# Load raw data for Swiss inflation (CPI in %)
data_inflation_full <- read_excel("API_FP.CPI.TOTL.ZG_DS2_en_excel_v2_5454868.xls", sheet = 1, col_names = FALSE)
data_inflation <- data.frame(t(data_inflation_full[4:nrow(data_inflation_full), ]))
colnames(data_inflation) <- data_inflation[1, ]
data_inflation <- data_inflation[-(1:4), ]
names(data_inflation)[1] <- "Dates"
swiss_inflation <- data_inflation[, c('Dates', 'Switzerland')]
# Load and merge raw data for CHF money market rates and CHF spot interest rates on Swiss Confederation bond issues
data_ST_rf_CHF <- read_excel("snb-chart-data-zimomach-en-all-20230502_1430.xlsx", skip = 15, col_names = TRUE)
data_LT_rf_CHF <- read_excel("snb-chart-data-rendeidglfzch-en-all-20230502_1430.xlsx", skip = 15, col_names = TRUE)
names(data_ST_rf_CHF)[1] <- "Dates"
names(data_LT_rf_CHF)[1] <- "Dates"
data_ST_rf_CHF <- data_ST_rf_CHF[, c('Dates', 'SARON close of trading')]
CHF_rf_rates <- merge(data_ST_rf_CHF, data_LT_rf_CHF, by = "Dates", all = TRUE)
# Inspect the size of the downloaded data
print(paste("data_indices_full (downloaded):", round(object.size(data_indices_full) / 1048576, 2), "MB"))
print(paste("data_FX_full (downloaded):", round(object.size(data_FX_full) / 1048576, 2), "MB"))
print(paste("data_inflation_full (downloaded):", round(object.size(data_inflation_full) / 1048576, 2), "MB"))
print(paste("data_ST_rf_CHF (downloaded):", round(object.size(data_ST_rf_CHF) / 1048576, 2), "MB"))
print(paste("data_ST_rf_CHF (downloaded):", round(object.size(data_ST_rf_CHF) / 1048576, 2), "MB"))
# Remove from our R environment the variables that we no longer need
rm(data_indices_full, data_FX_full, data_inflation_full, data_inflation, data_ST_rf_CHF, data_LT_rf_CHF)
# Inspect the size of the raw data that we continue from
print(paste("index_prices_local_currency:", round(object.size(index_prices_local_currency) / 1048576, 2), "MB"))
print(paste("CHF_FX:", round(object.size(CHF_FX) / 1048576, 2), "MB"))
print(paste("CHF_rf_rates:", round(object.size(CHF_rf_rates) / 1048576, 2), "MB"))
print(paste("swiss_inflation:", round(object.size(swiss_inflation) / 1048576, 2), "MB"))
##############################################################################
# DATA CLEANING AND DATA INTEGRATION
# Inspect classes of the  Dates columns of the different data frames
class(index_prices_local_currency$Dates)
class(CHF_FX$Dates)
class(swiss_inflation$Dates)
class(CHF_rf_rates$Dates)
# Convert Dates to a Date object
index_prices_local_currency$Dates <- as.Date(index_prices_local_currency$Dates)
CHF_FX$Dates <- as.Date(CHF_FX$Dates)
CHF_rf_rates$Dates <- as.Date(CHF_rf_rates$Dates)
swiss_inflation$Dates <- as.Date(paste(swiss_inflation$Dates, "-01-01", sep = ""), format = "%Y-%m-%d")
# Sort the data frames by the 'Dates' column in descending order (from most recent to older)
index_prices_local_currency <- index_prices_local_currency[order(index_prices_local_currency$Dates, decreasing = TRUE),]
CHF_FX <- CHF_FX[order(CHF_FX$Dates, decreasing = TRUE),]
swiss_inflation <- swiss_inflation[order(swiss_inflation$Dates, decreasing = TRUE),]
CHF_rf_rates <- CHF_rf_rates[order(CHF_rf_rates$Dates, decreasing = TRUE),]
# Change the column name for Swiss inflation (CPI in %) and convert the data to actual percentages
if (names(swiss_inflation)[2] == "Switzerland") {
names(swiss_inflation)[2] <- "Swiss inflation (CPI)"
swiss_inflation$"Swiss inflation (CPI)" <- as.numeric(swiss_inflation$"Swiss inflation (CPI)") / 100
}
# Convert "#N/A N/A" to NA (in character or factor columns only)
is_char_or_factor <- sapply(index_prices_local_currency, function(col) is.character(col) | is.factor(col))
index_prices_local_currency[is_char_or_factor] <- lapply(index_prices_local_currency[is_char_or_factor], function(col) {
ifelse(col == "#N/A N/A", NA, col)
})
is_char_or_factor <- sapply(CHF_FX, function(col) is.character(col) | is.factor(col))
CHF_FX[is_char_or_factor] <- lapply(CHF_FX[is_char_or_factor], function(col) {
ifelse(col == "#N/A N/A", NA, col)
})
# Determine indices that do not contain sufficiently long dated price data and are not essential to the investment universe
index_prices_local_currency_NA_dates <- determine_start_dates(index_prices_local_currency)
print(index_prices_local_currency_NA_dates)
# Remove indices (columns) that do not contain sufficiently long dated price data and are not essential to the investment universe
# --> removing mid cap equity indices (insufficiently long dated price data for Switzerland, remove the corresponding index for other geographies, and total stock market index already covers large- and mid-cap equity)
# --> removing large cap equity indices (total stock market index already covers large- and mid-cap equity)
# --> removing real estate index (insufficiently long dated price data)
# --> removing 2 duplicates of I08240CH
index_prices_local_currency <- index_prices_local_currency[, !(colnames(index_prices_local_currency) %in% c("MXCHMC Index", "MXEUMC Index", "MXUSMC Index", "MXEFMC Index", "MXWOMC Index",
"MXUSLC Index", "MXEULC Index", "MXEFLC Index", "MXCHLC Index", "MXWOLC Index",
"TENHGU Index",
"I08240 Index", "I08240EU Index"))]
# Determine currency pairs that do not contain sufficiently long dated price data and are not essential to the investment universe
CHF_FX_NA_dates <- determine_start_dates(CHF_FX)
print(CHF_FX_NA_dates)
# Remove currency pairs (columns) that do not contain sufficiently long dated price data and are not essential to the investment universe
# NOT APPLICABLE
# Provide better names to remaining columns of dataframes index_prices_local_currency and CHF_FX
index_prices_local_currency <- rename_columns(index_prices_local_currency)
CHF_FX <- rename_columns(CHF_FX)
# Transform non-NA values from character to numeric
index_prices_local_currency <- index_prices_local_currency %>%
mutate_at(
vars(-Dates),
~as.numeric(na_if(., ""))  # Convert non-empty strings to numeric
)
CHF_FX <- CHF_FX %>%
mutate_at(
vars(-Dates),
~as.numeric(na_if(., ""))  # Convert non-empty strings to numeric
)
# For each geography, combine the three intermediate-term treasuries (3-5Y, 5-7Y, 7-10Y) into one investable security that is weighted 1/3 in each
index_prices_local_currency <- index_prices_local_currency %>%
mutate(`US IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`US IT treasuries 3-5Y` + `US IT treasuries 5-7Y` + `US IT treasuries 7-10Y`) / 3,
`Europe IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`Europe IT treasuries 3-5Y` + `Europe IT treasuries 5-7Y` + `Europe IT treasuries 7-10Y`) / 3,
`EM IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`EM IT treasuries 3-5Y` + `EM IT treasuries 5-7Y` + `EM IT treasuries 7-10Y`) / 3,
`Switzerland IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`Switzerland IT treasuries 3-5Y` + `Switzerland IT treasuries 5-7Y` + `Switzerland IT treasuries 7-10Y`) / 3,
`World IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`World IT treasuries 3-5Y` + `World IT treasuries 5-7Y` + `World IT treasuries 7-10Y`) / 3)
# Remove the original intermediate-term treasuries columns
index_prices_local_currency <- index_prices_local_currency %>%
select(-ends_with("3-5Y"), -ends_with("5-7Y"), -ends_with("7-10Y"))
# Rearrange the indices (columns) to a more logical order
index_prices_local_currency <- rearrange_columns(index_prices_local_currency)
# Remove longer dated observations until each column contains values for each remaining date (row)
# i.e. Filter the data frames to include only rows starting from the latest start date
index_prices_local_currency <- filter(index_prices_local_currency,
Dates > max(determine_start_dates(index_prices_local_currency)))
CHF_FX <- filter(CHF_FX,
Dates >= max(determine_start_dates(index_prices_local_currency)))
CHF_rf_rates <- filter(CHF_rf_rates,
Dates >= max(determine_start_dates(index_prices_local_currency)))
# Generate dataframe containing index prices in CHF (calculated from index_prices_local_currency and CHF_FX)
# Initialize dataframe that will contain index prices in CHF
index_prices_CHF <- index_prices_local_currency
# Select the columns representing USD, EUR, and CHF denominated indexes
usd_indexes <- c("US", "US small cap", "Europe small cap", "EM", "EM small cap", "Switzerland small cap", "World", "World small cap", "US ST treasuries 1-3Y", "US IT treasuries (3-5Y, 5-7Y, 7-10Y)", "US LT treasuries 10Y+", "EM ST treasuries 1-3Y", "EM IT treasuries (3-5Y, 5-7Y, 7-10Y)", "EM LT treasuries 10Y+", "World ST treasuries 1-3Y", "World IT treasuries (3-5Y, 5-7Y, 7-10Y)", "World LT treasuries 10Y+", "Gold bullion")
eur_indexes <- c("Europe", "Europe ST treasuries 1-3Y", "Europe IT treasuries (3-5Y, 5-7Y, 7-10Y)", "Europe LT treasuries 10Y+")
chf_indexes <- c("Switzerland", "Switzerland ST treasuries 1-3Y", "Switzerland IT treasuries (3-5Y, 5-7Y, 7-10Y)", "Switzerland LT treasuries 10Y+")
# Multiply USD denominated columns by CHF/USD exchange rate
index_prices_CHF[, usd_indexes] <- index_prices_CHF[, usd_indexes] * CHF_FX[["CHF per USD"]]
# Multiply EUR denominated columns by CHF/EUR exchange rate
index_prices_CHF[, eur_indexes] <- index_prices_CHF[, eur_indexes] * CHF_FX[["CHF per EUR"]]
# Inspect dataframe index_prices_CHF
print(index_prices_CHF)
colnames(index_prices_CHF)
head(index_prices_CHF, 10)
tail(index_prices_CHF, 10)
# Generate dataframe containing daily price returns in CHF (calculated from index_prices_CHF)
# Initialize dataframe that will contain daily price returns in CHF
index_daily_returns_CHF <- data.frame(index_prices_CHF$Dates)
names(index_daily_returns_CHF)[1] <- "Dates"
# Calculate daily price returns for each index in CHF
num_rows <- nrow(index_prices_CHF)
for (col in colnames(index_prices_CHF)[-1]) {
prices <- index_prices_CHF[[col]]
returns <- (prices[1:(num_rows - 1)] / prices[2:num_rows]) - 1
index_daily_returns_CHF[[col]] <- c(returns, NA)
}
index_daily_returns_CHF <- na.omit(index_daily_returns_CHF) # This removes the final row, which only contains returns of value NA
# Inspect the size of the cleaned data that we continue from
print(paste("index_daily_returns_CHF:", round(object.size(index_daily_returns_CHF) / 1048576, 2), "MB"))
print(paste("CHF_FX:", round(object.size(CHF_FX) / 1048576, 2), "MB"))
print(paste("CHF_rf_rates:", round(object.size(CHF_rf_rates) / 1048576, 2), "MB"))
print(paste("swiss_inflation:", round(object.size(swiss_inflation) / 1048576, 2), "MB"))
##############################################################################
# DATA PREPARATION
# Feature engineering a large set of investment strategies (as separate columns). Strategies differ in:
# (a) their strategic asset allocation, i.e. different (equally-weighted) combinations of the 26 index return series.
# (b) their rebalancing technique: periodic (e.g., daily/monthly/quarterly-semi-annually/annually) or threshold-based (e.g., 10%/20%/25% deviation from original weight)
# Notice that, as we increase the number of combinations that we implement, the number of additional columns increases exponentially.
# Generating new columns (different investment strategies) from our daily index returns in CHF
# Define a function that generates columns of equally-weighted indices, with daily rebalancing
generate_weighted_cols <- function(index_returns, max_comb_size) {
# Start timer to later display how long the function took to run
start_time <- Sys.time()
# Create a dataframe that contains the initial investment strategies (investing 100% in an index), without the Dates column
investment_strategies <- index_returns[, -1]
# Get the number of columns (indices) in the dataframe
num_cols <- ncol(investment_strategies)
# Iterate over i for i-combinations
for (i in 2:min(num_cols, max_comb_size)) {
# Generate all i-combinations of column indices
combos <- combinat::combn(1:num_cols, i, simplify = FALSE)
# Iterate over each combination
for (combo in combos) {
# Calculate the new column as the row-wise mean of the selected columns
new_col <- rowMeans(investment_strategies[, combo])
# Create the new column name
new_col_name <- paste(names(investment_strategies)[combo], collapse = " ")
# Add the new column to the dataframe
index_returns[[new_col_name]] <- new_col
}
}
# Display how long the function took to run
end_time <- Sys.time()
execution_time <- as.numeric(end_time - start_time, units = "secs")
print(paste("Execution time: ", execution_time, "seconds"))
return(index_returns)
}
# Generate columns of equally-weighted indices, with daily rebalancing
strategies_max_2_comb_daily_rebal <- generate_weighted_cols(index_daily_returns_CHF, 2)
strategies_max_3_comb_daily_rebal <- generate_weighted_cols(index_daily_returns_CHF, 3)
strategies_max_4_comb_daily_rebal <- generate_weighted_cols(index_daily_returns_CHF, 4)
# Merge all candidate investment strategies (including the separate initial indices) into one data frame "all_candidate_strategies_max_4_comb"
all_strategies_max_4_comb_daily_rebal <- merge(index_daily_returns_CHF, strategies_max_4_comb_daily_rebal, by = "Dates")
# Inspect (a subset of) the initial, the generated and the merged dataframes
head(index_daily_returns_CHF, 5)
tail(index_daily_returns_CHF, 5)
print(index_daily_returns_CHF)
head(strategies_max_2_comb_daily_rebal[, 1:30], 5)
tail(strategies_max_2_comb_daily_rebal[, 1:30], 5)
print(strategies_max_2_comb_daily_rebal[,1:30])
head(strategies_max_3_comb_daily_rebal[, 1:30], 5)
tail(strategies_max_3_comb_daily_rebal[, 1:30], 5)
print(strategies_max_3_comb_daily_rebal[,1:30])
head(strategies_max_4_comb_daily_rebal[, 1:30], 5)
tail(strategies_max_4_comb_daily_rebal[, 1:30], 5)
print(strategies_max_4_comb_daily_rebal[,1:30])
# Inspect a subset of the merged dataframe
head(all_strategies_max_4_comb_daily_rebal[, 1:30], 5)
tail(all_strategies_max_4_comb_daily_rebal[, 1:30], 5)
print(all_strategies_max_4_comb_daily_rebal[,1:30])
# Inspect the size of the generated and merged data that contains the different investment strategies
print(paste("strategies_max_2_comb_daily_rebal (generated):", round(object.size(strategies_max_2_comb_daily_rebal) / 1048576, 2), "MB"))
print(paste("strategies_max_3_comb_daily_rebal (generated):", round(object.size(strategies_max_3_comb_daily_rebal) / 1048576, 2), "MB"))
print(paste("strategies_max_4_comb_daily_rebal (generated):", round(object.size(strategies_max_4_comb_daily_rebal) / 1048576, 2), "MB"))
print(paste("all_strategies_max_4_comb_daily_rebal (generated):", round(object.size(all_strategies_max_4_comb_daily_rebal) / 1048576, 2), "MB"))
View(strategies_max_2_comb_daily_rebal)
View(strategies_max_2_comb_daily_rebal)
# Generating new columns (different investment strategies) from our daily index returns in CHF
# Define a function that generates columns of equally-weighted indices, with daily rebalancing
generate_weighted_cols <- function(index_returns, max_comb_size) {
# Start timer to later display how long the function took to run
start_time <- Sys.time()
# Create a dataframe that contains the initial investment strategies (investing 100% in an index), without the Dates column
investment_strategies <- index_returns[, -1]
# Get the number of columns (indices) in the dataframe
num_cols <- ncol(investment_strategies)
# Iterate over i for i-combinations
for (i in 2:min(num_cols, max_comb_size)) {
# Generate all i-combinations of column indices
combos <- combinat::combn(1:num_cols, i, simplify = FALSE)
# Iterate over each combination
for (combo in combos) {
# Calculate the new column as the row-wise mean of the selected columns
new_col <- rowMeans(investment_strategies[, combo])
# Create the new column name
new_col_name <- paste(names(investment_strategies)[combo], collapse = " | ")
# Add the new column to the dataframe
index_returns[[new_col_name]] <- new_col
}
}
# Display how long the function took to run
end_time <- Sys.time()
execution_time <- as.numeric(end_time - start_time, units = "secs")
print(paste("Execution time: ", execution_time, "seconds"))
return(index_returns)
}
# Generate columns of equally-weighted indices, with daily rebalancing
strategies_max_2_comb_daily_rebal <- generate_weighted_cols(index_daily_returns_CHF, 2)
strategies_max_3_comb_daily_rebal <- generate_weighted_cols(index_daily_returns_CHF, 3)
View(strategies_max_2_comb_daily_rebal)
View(strategies_max_2_comb_daily_rebal)
head(strategies_max_3_comb_daily_rebal[, 1:30], 5)
tail(strategies_max_3_comb_daily_rebal[, 1:30], 5)
head(strategies_max_3_comb_daily_rebal[, 1:30], 5)
tail(strategies_max_3_comb_daily_rebal[, 1:30], 5)
tail(strategies_max_2_comb_daily_rebal, 5)
head(strategies_max_2_comb_daily_rebal, 5)
# Assisted by ChatGPT (https://chat.openai.com/) while writing the code below.
# Load packages
library(combinat)
library(foreach)
library(doParallel)
library(readxl)
library(progress)
library(dplyr)
library(parallel)
library(future.apply)
library(progressr)
library(RSQLite)
library(DBI)
library(ggplot2)
library(reshape2)
library(scales)
##############################################################################
# Get the directory path of the current code file
PATH <- dirname(rstudioapi::getSourceEditorContext()$path)
# Set the working directory to that of the current code file
setwd(PATH)
# Load functions file
source("BDA_BDBD_functions - Luca.R")
##############################################################################
# DATA COLLECTION: leveraging data from multiple sources
# Loading the raw data into R from different sources, each with different data formats.
# Load raw data for prices of selected indices
data_indices_full <- read_excel("Bloomberg_Terminal-spreadsheet_builder.xlsx", sheet = 1, col_names = FALSE)
index_prices_local_currency <- data_indices_full[7:nrow(data_indices_full), ]
colnames(index_prices_local_currency) <- data_indices_full[4, ]
names(index_prices_local_currency)[1] <- "Dates"
index_prices_local_currency$Dates <- as.Date(as.numeric(index_prices_local_currency$Dates), origin = "1899-12-30")
# Load raw data for prices of selected indices
data_FX_full <- read_excel("Bloomberg_Terminal-spreadsheet_builder.xlsx", sheet = 2, col_names = FALSE)
CHF_FX <- data_FX_full[7:nrow(data_indices_full), ]
colnames(CHF_FX) <- data_FX_full[4, ]
names(CHF_FX)[1] <- "Dates"
CHF_FX$Dates <- as.Date(as.numeric(CHF_FX$Dates), origin = "1899-12-30")
# Load raw data for Swiss inflation (CPI in %)
data_inflation_full <- read_excel("API_FP.CPI.TOTL.ZG_DS2_en_excel_v2_5454868.xls", sheet = 1, col_names = FALSE)
