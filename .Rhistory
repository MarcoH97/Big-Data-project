# Compute and print the total execution time of part 3
timer_end_3 <- Sys.time()
timer_3 <- as.numeric(timer_end_3 - timer_start_3, units = "secs")
print(paste("Execution time for PART 3: ", round(timer_3, 2), "seconds"))
# Start timer for performance tracking of part 4
timer_start_4 <- Sys.time()
# Extract plot data for the optimal strategy
plot_optimal_strategy_data <- ggplot_build(plot_list_different_periods_within_strategies[[optimal_strategy]])$data[[1]]
# Generate a plot that visualizes worst-case, best-case, and other return series for the optimal strategy
plot_optimal_strategy <-
ggplot() +
geom_line(data = plot_optimal_strategy_data, aes(x = x, y = y, color = colour), alpha = 0.2) +
geom_line(data = data.frame(Year = 1:length(lowest_series[[optimal_strategy]])/252, Return = lowest_series[[optimal_strategy]]), aes(x = Year, y = Return), color = "red") +
geom_line(data = data.frame(Year = 1:length(highest_series[[optimal_strategy]])/252, Return = highest_series[[optimal_strategy]]), aes(x = Year, y = Return), color = "green") +
geom_hline(yintercept = minimum_allowable_percentage, linetype = "dashed", color = "red") +
labs(title = paste("Worst-case, best-case and other historic return series for your optimal strategy:", optimal_strategy), x = "Years invested", y = "Cumulative return") +
theme_minimal() +
theme(legend.position="none") +
scale_y_continuous(limits = c(0, NA))
# Compute and print the total execution time of part 4
timer_end_4 <- Sys.time()
timer_4 <- as.numeric(timer_end_4 - timer_start_4, units = "secs")
print(paste("Execution time for PART 4: ", round(timer_4, 2), "seconds"))
# Compute and print the total execution time of TOTAL FUNCTION
total_function_end_0 <- Sys.time()
total_function_time_0 <- as.numeric(total_function_end_0 - total_function_start_0, units = "secs")
print(paste("Execution time for TOTAL FUNCTION: ", round(total_function_time_0, 2), "seconds"))
# Return the plots, optimal strategy, and data frames of results
return(list(plot_lowest_cum_returns, optimal_strategy, plot_optimal_strategy, df_above_threshold, df_refused, plot_list_different_periods_within_strategies, total_function_time_0))
}
#' A simplified function to determine the optimal investment strategy based on historical data.
#'
#' This function takes into consideration all possible start times within a given time horizon and a minimum acceptable cumulative return.
#' It performs the following main computations:
#' 1. For each strategy, it evaluates all possible periods within the specified time horizon, and keeps track of the lowest and highest cumulative return.
#' 2. It discards strategies that at any point drop below the minimum acceptable cumulative return, and it identifies the optimal strategy as the one with the highest minimum cumulative return.
#' This function excludes generating plots to visualize the different historic return series for each strategy and the evolution of the lowest cumulative return.
#'
#' @param df_return_series A data frame containing the return series of different strategies.
#' @param time_horizon_years The time horizon in years.
#' @param minimum_allowable_percentage The minimum allowable cumulative return percentage below which a strategy should be excluded.
#' @param granularity The level of granularity (e.g., "daily", "weekly", "monthly", etc.) to use for skipping intervals in the analysis. Defaults to "daily".
#'
#' @return A list containing the following elements:
#' - optimal_strategy: the investment strategy that provides the highest minimum cumulative return over all possible periods within the time horizon and doesn't fall below the minimum allowable percentage return.
#' - df_above_threshold: a data frame containing strategies that have not been excluded, their lowest and highest cumulative returns.
#' - df_refused: a data frame containing excluded strategies.
#' - total_function_time: the total execution time of the function, in seconds.
determine_optimal_strategy_simplified <- function(df_return_series, time_horizon_years,
minimum_allowable_percentage, granularity = "daily") {
# Start timer for performance tracking
total_function_start <- Sys.time()
# Set granularity level for skipping intervals in the analysis
granularity <- tolower(granularity)
skip <- switch(granularity,
"daily" = 1,
"weekly" = 5,
"monthly" = 21,
"quarterly" = 63,
"bi-annually" = 126,
"annually" = 252,
stop("Invalid granularity"))
# Initialize constants and variables
days_per_year <- 252
time_horizon_days <- time_horizon_years * days_per_year
# Initialize data frames to store results
df_above_threshold <- data.frame(Strategy = character(), LowestCumulativeReturn = numeric())
df_refused <- data.frame(Strategy = character())
# Initialize lists to store the lowest and highest return series for each strategy
lowest_series <- list()
highest_series <- list()
# Main loop over each strategy
for (col in names(df_return_series)[-1]) {
# Initialization of variables for current strategy
lowest_cumulative_return <- Inf
highest_cumulative_return <- -Inf
lowest_cumulative_series <- NULL
highest_cumulative_series <- NULL
exclude <- FALSE
# Loop over all possible starting times for the specified time horizon
for (i in seq(1, (nrow(df_return_series) - time_horizon_days + 1), by = skip)) {
# Compute cumulative returns for the current time period
cum_returns_time_period <- cumprod(1 + df_return_series[i:(i + time_horizon_days - 1), col])
# Check if the minimum cumulative return is below the threshold.
# If so, exclude the strategy, add it to df_refused and break out of the current loop
if (any(cum_returns_time_period < minimum_allowable_percentage)) {
exclude <- TRUE
df_refused <- rbind(df_refused, data.frame(Strategy = col))
break
}
# Keep track of the lowest cumulative return for the current strategy
if (cum_returns_time_period[length(cum_returns_time_period)] < lowest_cumulative_return) {
lowest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
lowest_cumulative_series <- cum_returns_time_period
}
# Keep track of the highest cumulative return for the current strategy
if (cum_returns_time_period[length(cum_returns_time_period)] > highest_cumulative_return) {
highest_cumulative_return <- cum_returns_time_period[length(cum_returns_time_period)]
highest_cumulative_series <- cum_returns_time_period
}
}
# If the strategy is not marked for exclusion add to df_above_threshold
if (exclude == FALSE) {
df_above_threshold <- rbind(df_above_threshold, data.frame(Strategy = col, LowestCumulativeReturn = lowest_cumulative_return, HighestCumulativeReturn = highest_cumulative_return))
lowest_series[[col]] <- lowest_cumulative_series
highest_series[[col]] <- highest_cumulative_series
}
}
# Select the optimal strategy as the one with the highest minimum cumulative return that didn't fall below the threshold
optimal_strategy <- df_above_threshold[which.max(df_above_threshold$LowestCumulativeReturn), "Strategy"]
# Compute and print the total execution time of the function
total_function_end <- Sys.time()
total_function_time <- as.numeric(total_function_end - total_function_start, units = "secs")
# Return a list with the optimal strategy, two data frames for the strategies above threshold and refused, and the total execution time of the function
return(list(optimal_strategy, df_above_threshold, df_refused, total_function_time))
}
# An advanced version of the determine_optimal_strategy function.
# This function iterates over different granularities and progressively refines the data to analyze based on the top X-percentile strategies at each level of granularity.
# The function implements a modified version of the determine_optimal_strategy function at each granularity level.
# At the end of the process, the remaining top strategies are returned with the results from the final granularity level.
#
# @param df_return_series A data frame containing the return series of different strategies.
# @param time_horizon_years The time horizon in years.
# @param minimum_allowable_percentage The minimum allowable cumulative return percentage below which a strategy should be excluded.
# @param X_percentile The top X-percentile of strategies to keep for the next level of granularity. Defaults to 0.50.
#
# @return A list containing the results of the analysis on the final level of granularity and the total execution time.
determine_optimal_strategy_advanced_A <- function(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.40) {
# Start timer for performance tracking
total_function_start <- Sys.time()
# Define the granularities to be used in sequence
granularities <- c("annually", "bi-annually", "quarterly", "monthly", "weekly", "daily")
# Initialize the data to the full dataset
data_to_analyze <- df_return_series
for (granularity in granularities) {
# Determine the optimal strategies for the current level of granularity
results <- determine_optimal_strategy_simplified(data_to_analyze, time_horizon_years,
minimum_allowable_percentage, granularity)
# Get the top X-percentile strategies
top_X_percentile <- quantile(results[[2]]$LowestCumulativeReturn, X_percentile)
# Get the strategies whose LowestCumulativeReturn > top_40
top_strategies <- results[[2]]$Strategy[results[[2]]$LowestCumulativeReturn > top_X_percentile]
# Filter the strategies for the next level of granularity
data_to_analyze <- data_to_analyze[ , c("Dates", top_strategies)]
print(paste("Current level of granularity:", granularity))
print("Top remaining strategies for further analysis:")
print(colnames(data_to_analyze))
# If less than 2 strategies remain, break the loop
if (ncol(data_to_analyze) <= 2) {
break
}
}
# Compute and print the total execution time of the function
total_function_end <- Sys.time()
total_function_time <- as.numeric(total_function_end - total_function_start, units = "secs")
print(paste("Execution time for TOTAL FUNCTION: ", round(total_function_time, 2), "seconds"))
results[[4]] <- total_function_time
# Return the results from the final granularity level
return(results)
}
# An advanced version of the determine_optimal_strategy function.
# This function iterates over different granularities and progressively refines the data to analyze based on the top X-percentile strategies at each level of granularity.
# If no strategy remains at a certain granularity level, the function rolls back to the previous granularity level and gets the "2nd_X_percentile" strategies to continue the process.
# The function implements a modified version of the determine_optimal_strategy function at each granularity level.
# At the end of the process, the remaining top strategies are returned with the results from the final granularity level.
#
# @param df_return_series A data frame containing the return series of different strategies.
# @param time_horizon_years The time horizon in years.
# @param minimum_allowable_percentage The minimum allowable cumulative return percentage below which a strategy should be excluded.
# @param X_percentile The top X-percentile of strategies to keep for the next level of granularity. Defaults to 0.40.
#
# @return A list containing the results of the analysis on the final level of granularity and the total execution time.
determine_optimal_strategy_advanced_B <- function(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.40) {
# Start timer for performance tracking
total_function_start <- Sys.time()
# Define the granularities to be used in sequence
granularities <- c("annually", "bi-annually", "quarterly", "monthly", "weekly", "daily")
# Initialize the data to the full dataset
data_to_analyze <- df_return_series
# Create a list to store the results for each granularity
results_list <- list()
for (granularity in granularities) {
# Determine the optimal strategies for the current level of granularity
results <- determine_optimal_strategy_simplified(data_to_analyze, time_horizon_years,
minimum_allowable_percentage, granularity)
# Save the results for this granularity level
results_list[[granularity]] <- results
# Get the top X-percentile strategies
top_X_percentile <- quantile(results[[2]]$LowestCumulativeReturn, X_percentile)
# Get the strategies whose LowestCumulativeReturn > top_X_percentile
top_strategies <- results[[2]]$Strategy[results[[2]]$LowestCumulativeReturn > top_X_percentile]
# Filter the strategies for the next level of granularity
data_to_analyze <- data_to_analyze[ , c("Dates", top_strategies)]
print(paste("Current level of granularity:", granularity))
print("Top remaining strategies for further analysis:")
print(colnames(data_to_analyze))
# If no strategy remains, move back to the previous granularity level and get the "2nd_X_percentile" strategies
if (ncol(data_to_analyze) <= 1) {
# Get the index of the current granularity
current_index <- which(granularities == granularity)
# If it's not the first granularity level, move back
if (current_index > 1) {
previous_results <- results_list[[granularities[current_index - 1]]]
# Calculate the 2nd_X_percentile strategies from previous_results
second_X_percentile <- quantile(previous_results[[2]]$LowestCumulativeReturn, 2 * X_percentile)
top_strategies <- previous_results[[2]]$Strategy[previous_results[[2]]$LowestCumulativeReturn > second_X_percentile]
# Filter the strategies again
data_to_analyze <- data_to_analyze[ , c("Dates", top_strategies)]
}
}
# If less than 2 strategies remain, break the loop
if (ncol(data_to_analyze) <= 2) {
break
}
}
# Compute and print the total execution time of the function
total_function_end <- Sys.time()
total_function_time <- as.numeric(total_function_end - total_function_start, units = "secs")
print(paste("Execution time for TOTAL FUNCTION: ", round(total_function_time, 2), "seconds"))
results[[4]] <- total_function_time
# Return the results from the final granularity level
return(results)
}
determine_optimal_strategy_v2 <- function(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.50) {
return(...)
}
# df_return_series <- index_daily_returns_CHF
df_return_series <- strategies_max_2_comb_daily_rebal
# df_return_series <- strategies_max_3_comb_daily_rebal
# df_return_series <- strategies_max_4_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
granularity = "quarterly"
results_simplified_optimal_strategy <- determine_optimal_strategy_simplified(df_return_series, time_horizon_years,
minimum_allowable_percentage, granularity)
print(results_simplified_optimal_strategy[[1]])
head(results_simplified_optimal_strategy[[2]], 5)
tail(results_simplified_optimal_strategy[[2]], 5)
head(results_simplified_optimal_strategy[[3]], 5)
tail(results_simplified_optimal_strategy[[3]], 5)
print(paste("Execution time for TOTAL FUNCTION: ", round(results_simplified_optimal_strategy[[4]], 2), "seconds"))
print(results_simplified_optimal_strategy[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_simplified_optimal_strategy[[4]], 2), "seconds"))
head(results_simplified_optimal_strategy[[2]], 5)
print(results_simplified_optimal_strategy[[1]])
results_simplified_optimal_strategy[[2]]$Strategy
results_simplified_optimal_strategy[[2]]$Strategy[US LT treasuries 10Y+]
results_simplified_optimal_strategy[[2]]$Strategy["US LT treasuries 10Y+"]
results_simplified_optimal_strategy[[2]]$Strategy[["US LT treasuries 10Y+"]]
# df_return_series <- index_daily_returns_CHF
df_return_series <- strategies_max_2_comb_daily_rebal
# df_return_series <- strategies_max_3_comb_daily_rebal
# df_return_series <- strategies_max_4_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
granularity = "quarterly"
results_simplified_optimal_strategy <- determine_optimal_strategy_simplified(df_return_series, time_horizon_years,
minimum_allowable_percentage, granularity)
print(results_simplified_optimal_strategy[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_simplified_optimal_strategy[[4]], 2), "seconds"))
results_simplified_optimal_strategy[[2]]$Strategy["US LT treasuries 10Y+"]
head(results_simplified_optimal_strategy[[2]], 5)
head(results_simplified_optimal_strategy[[2]], 5)
tail(results_simplified_optimal_strategy[[2]], 5)
head(results_simplified_optimal_strategy[[3]], 5)
tail(results_simplified_optimal_strategy[[3]], 5)
print(results_simplified_optimal_strategy[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_simplified_optimal_strategy[[4]], 2), "seconds"))
head(results_simplified_optimal_strategy[[2]], 3)
tail(results_simplified_optimal_strategy[[2]], 3)
head(results_simplified_optimal_strategy[[3]], 3)
tail(results_simplified_optimal_strategy[[3]], 3)
# df_return_series <- index_daily_returns_CHF
df_return_series <- strategies_max_2_comb_daily_rebal
# df_return_series <- strategies_max_3_comb_daily_rebal
# df_return_series <- strategies_max_4_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
results_advanced_optimal_strategy <- determine_optimal_strategy_advanced_A(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.40)
# This function iterates over different granularities and progressively refines the data to analyze based on the top X-percentile strategies at each level of granularity.
# The function implements a modified version of the determine_optimal_strategy function at each granularity level.
# At the end of the process, the remaining top strategies are returned with the results from the final granularity level.
#
# @param df_return_series A data frame containing the return series of different strategies.
# @param time_horizon_years The time horizon in years.
# @param minimum_allowable_percentage The minimum allowable cumulative return percentage below which a strategy should be excluded.
# @param X_percentile The top X-percentile of strategies to keep for the next level of granularity. Defaults to 0.50.
#
# @return A list containing the results of the analysis on the final level of granularity and the total execution time.
determine_optimal_strategy_advanced_A <- function(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.40) {
# Start timer for performance tracking
total_function_start <- Sys.time()
# Define the granularities to be used in sequence
granularities <- c("annually", "bi-annually", "quarterly", "monthly", "weekly", "daily")
# Initialize the data to the full dataset
data_to_analyze <- df_return_series
for (granularity in granularities) {
# Determine the optimal strategies for the current level of granularity
results <- determine_optimal_strategy_simplified(data_to_analyze, time_horizon_years,
minimum_allowable_percentage, granularity)
# Get the top X-percentile strategies
top_X_percentile <- quantile(results[[2]]$LowestCumulativeReturn, X_percentile)
# Get the strategies whose LowestCumulativeReturn > top_40
top_strategies <- results[[2]]$Strategy[results[[2]]$LowestCumulativeReturn > top_X_percentile]
# Filter the strategies for the next level of granularity
data_to_analyze <- data_to_analyze[ , c("Dates", top_strategies)]
print(paste("Current level of granularity:", granularity))
print("Top remaining strategies for further analysis:")
print(colnames(data_to_analyze[,-1]))
# If less than 2 strategies remain, break the loop
if (ncol(data_to_analyze) <= 2) {
break
}
}
# Compute and print the total execution time of the function
total_function_end <- Sys.time()
total_function_time <- as.numeric(total_function_end - total_function_start, units = "secs")
print(paste("Execution time for TOTAL FUNCTION: ", round(total_function_time, 2), "seconds"))
results[[4]] <- total_function_time
# Return the results from the final granularity level
return(results)
}
# If no strategy remains at a certain granularity level, the function rolls back to the previous granularity level and gets the "2nd_X_percentile" strategies to continue the process.
# The function implements a modified version of the determine_optimal_strategy function at each granularity level.
# At the end of the process, the remaining top strategies are returned with the results from the final granularity level.
#
# @param df_return_series A data frame containing the return series of different strategies.
# @param time_horizon_years The time horizon in years.
# @param minimum_allowable_percentage The minimum allowable cumulative return percentage below which a strategy should be excluded.
# @param X_percentile The top X-percentile of strategies to keep for the next level of granularity. Defaults to 0.40.
#
# @return A list containing the results of the analysis on the final level of granularity and the total execution time.
determine_optimal_strategy_advanced_B <- function(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.40) {
# Start timer for performance tracking
total_function_start <- Sys.time()
# Define the granularities to be used in sequence
granularities <- c("annually", "bi-annually", "quarterly", "monthly", "weekly", "daily")
# Initialize the data to the full dataset
data_to_analyze <- df_return_series
# Create a list to store the results for each granularity
results_list <- list()
for (granularity in granularities) {
# Determine the optimal strategies for the current level of granularity
results <- determine_optimal_strategy_simplified(data_to_analyze, time_horizon_years,
minimum_allowable_percentage, granularity)
# Save the results for this granularity level
results_list[[granularity]] <- results
# Get the top X-percentile strategies
top_X_percentile <- quantile(results[[2]]$LowestCumulativeReturn, X_percentile)
# Get the strategies whose LowestCumulativeReturn > top_X_percentile
top_strategies <- results[[2]]$Strategy[results[[2]]$LowestCumulativeReturn > top_X_percentile]
# Filter the strategies for the next level of granularity
data_to_analyze <- data_to_analyze[ , c("Dates", top_strategies)]
print(paste("Current level of granularity:", granularity))
print("Top remaining strategies for further analysis:")
print(colnames(data_to_analyze[,-1]))
# If no strategy remains, move back to the previous granularity level and get the "2nd_X_percentile" strategies
if (ncol(data_to_analyze) <= 1) {
# Get the index of the current granularity
current_index <- which(granularities == granularity)
# If it's not the first granularity level, move back
if (current_index > 1) {
previous_results <- results_list[[granularities[current_index - 1]]]
# Calculate the 2nd_X_percentile strategies from previous_results
second_X_percentile <- quantile(previous_results[[2]]$LowestCumulativeReturn, 2 * X_percentile)
top_strategies <- previous_results[[2]]$Strategy[previous_results[[2]]$LowestCumulativeReturn > second_X_percentile]
# Filter the strategies again
data_to_analyze <- data_to_analyze[ , c("Dates", top_strategies)]
}
}
# If less than 2 strategies remain, break the loop
if (ncol(data_to_analyze) <= 2) {
break
}
}
# Compute and print the total execution time of the function
total_function_end <- Sys.time()
total_function_time <- as.numeric(total_function_end - total_function_start, units = "secs")
print(paste("Execution time for TOTAL FUNCTION: ", round(total_function_time, 2), "seconds"))
results[[4]] <- total_function_time
# Return the results from the final granularity level
return(results)
}
# df_return_series <- index_daily_returns_CHF
df_return_series <- strategies_max_2_comb_daily_rebal
# df_return_series <- strategies_max_3_comb_daily_rebal
# df_return_series <- strategies_max_4_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
granularity = "quarterly"
results_simplified_optimal_strategy <- determine_optimal_strategy_simplified(df_return_series, time_horizon_years,
minimum_allowable_percentage, granularity)
print(results_simplified_optimal_strategy[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_simplified_optimal_strategy[[4]], 2), "seconds"))
head(results_simplified_optimal_strategy[[2]], 3)
tail(results_simplified_optimal_strategy[[2]], 3)
head(results_simplified_optimal_strategy[[3]], 3)
tail(results_simplified_optimal_strategy[[3]], 3)
# df_return_series <- index_daily_returns_CHF
df_return_series <- strategies_max_2_comb_daily_rebal
# df_return_series <- strategies_max_3_comb_daily_rebal
# df_return_series <- strategies_max_4_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
results_advanced_optimal_strategy <- determine_optimal_strategy_advanced_A(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.40)
print(results_advanced_optimal_strategy[[1]])
head(results_advanced_optimal_strategy[[2]], 5)
tail(results_advanced_optimal_strategy[[2]], 5)
head(results_advanced_optimal_strategy[[3]], 5)
tail(results_advanced_optimal_strategy[[3]], 5)
print(paste("Execution time for TOTAL FUNCTION: ", round(results_advanced_optimal_strategy[[4]], 2), "seconds"))
# df_return_series <- index_daily_returns_CHF
# df_return_series <- strategies_max_2_comb_daily_rebal
df_return_series <- strategies_max_3_comb_daily_rebal
# df_return_series <- strategies_max_4_comb_daily_rebal
time_horizon_years <- 12
# df_return_series <- index_daily_returns_CHF
df_return_series <- strategies_max_2_comb_daily_rebal
# df_return_series <- strategies_max_3_comb_daily_rebal
# df_return_series <- strategies_max_4_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
results_advanced_optimal_strategy <- determine_optimal_strategy_advanced_B(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.40)
print(results_advanced_optimal_strategy[[1]])
head(results_advanced_optimal_strategy[[2]], 5)
tail(results_advanced_optimal_strategy[[2]], 5)
head(results_advanced_optimal_strategy[[3]], 5)
tail(results_advanced_optimal_strategy[[3]], 5)
print(paste("Execution time for TOTAL FUNCTION: ", round(results_advanced_optimal_strategy[[4]], 2), "seconds"))
print(results_advanced_optimal_strategy[[1]])
# df_return_series <- index_daily_returns_CHF
# df_return_series <- strategies_max_2_comb_daily_rebal
df_return_series <- strategies_max_3_comb_daily_rebal
# df_return_series <- strategies_max_4_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
results_advanced_optimal_strategy_A <- determine_optimal_strategy_advanced_A(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.40)
df_return_series <- strategies_max_3_comb_daily_rebal
# df_return_series <- strategies_max_4_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
granularity = "annually"
results_simplified_optimal_strategy <- determine_optimal_strategy_simplified(df_return_series, time_horizon_years,
minimum_allowable_percentage, granularity)
print(results_simplified_optimal_strategy[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_simplified_optimal_strategy[[4]], 2), "seconds"))
df_return_series <- strategies_max_3_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
results_advanced_optimal_strategy_A <- determine_optimal_strategy_advanced_A(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.40)
df_return_series <- strategies_max_3_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
results_advanced_optimal_strategy_A <- determine_optimal_strategy_advanced_A(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.10)
df_return_series <- strategies_max_2_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
results_advanced_optimal_strategy_B <- determine_optimal_strategy_advanced_B(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.25)
print(results_advanced_optimal_strategy_B[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_advanced_optimal_strategy_B[[4]], 2), "seconds"))
df_return_series <- strategies_max_2_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
results_advanced_optimal_strategy_B <- determine_optimal_strategy_advanced_B(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.60)
df_return_series <- strategies_max_2_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
results_advanced_optimal_strategy_B <- determine_optimal_strategy_advanced_B(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.40)
print(results_advanced_optimal_strategy_B[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_advanced_optimal_strategy_B[[4]], 2), "seconds"))
df_return_series <- strategies_max_2_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
results_advanced_optimal_strategy_B <- determine_optimal_strategy_advanced_B(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.50)
print(results_advanced_optimal_strategy_B[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_advanced_optimal_strategy_B[[4]], 2), "seconds"))
df_return_series <- strategies_max_2_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
results_advanced_optimal_strategy_B <- determine_optimal_strategy_advanced_B(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.10)
print(results_advanced_optimal_strategy_B[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_advanced_optimal_strategy_B[[4]], 2), "seconds"))
df_return_series <- strategies_max_2_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
results_advanced_optimal_strategy_B <- determine_optimal_strategy_advanced_B(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.50)
print(results_advanced_optimal_strategy_B[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_advanced_optimal_strategy_B[[4]], 2), "seconds"))
df_return_series <- strategies_max_2_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
results_advanced_optimal_strategy_B <- determine_optimal_strategy_advanced_B(df_return_series, time_horizon_years,
minimum_allowable_percentage, X_percentile = 0.10)
print(results_advanced_optimal_strategy_B[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_advanced_optimal_strategy_B[[4]], 2), "seconds"))
