# Provide better names to remaining columns of dataframes index_prices_local_currency and CHF_FX
index_prices_local_currency <- rename_columns(index_prices_local_currency)
CHF_FX <- rename_columns(CHF_FX)
# Transform non-NA values from character to numeric
index_prices_local_currency <- index_prices_local_currency %>%
mutate_at(
vars(-Dates),
~as.numeric(na_if(., ""))  # Convert non-empty strings to numeric
)
CHF_FX <- CHF_FX %>%
mutate_at(
vars(-Dates),
~as.numeric(na_if(., ""))  # Convert non-empty strings to numeric
)
# For each geography, combine the three intermediate-term treasuries (3-5Y, 5-7Y, 7-10Y) into one investable security that is weighted 1/3 in each
index_prices_local_currency <- index_prices_local_currency %>%
mutate(`US IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`US IT treasuries 3-5Y` + `US IT treasuries 5-7Y` + `US IT treasuries 7-10Y`) / 3,
`Europe IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`Europe IT treasuries 3-5Y` + `Europe IT treasuries 5-7Y` + `Europe IT treasuries 7-10Y`) / 3,
`EM IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`EM IT treasuries 3-5Y` + `EM IT treasuries 5-7Y` + `EM IT treasuries 7-10Y`) / 3,
`Switzerland IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`Switzerland IT treasuries 3-5Y` + `Switzerland IT treasuries 5-7Y` + `Switzerland IT treasuries 7-10Y`) / 3,
`World IT treasuries (3-5Y, 5-7Y, 7-10Y)` = (`World IT treasuries 3-5Y` + `World IT treasuries 5-7Y` + `World IT treasuries 7-10Y`) / 3)
# Remove the original intermediate-term treasuries columns
index_prices_local_currency <- index_prices_local_currency %>%
select(-ends_with("3-5Y"), -ends_with("5-7Y"), -ends_with("7-10Y"))
# Rearrange the indices (columns) to a more logical order
index_prices_local_currency <- rearrange_columns(index_prices_local_currency)
# Remove longer dated observations until each column contains values for each remaining date (row)
# i.e. Filter the data frames to include only rows starting from the latest start date
index_prices_local_currency <- filter(index_prices_local_currency,
Dates > max(determine_start_dates(index_prices_local_currency)))
CHF_FX <- filter(CHF_FX,
Dates >= max(determine_start_dates(index_prices_local_currency)))
CHF_rf_rates <- filter(CHF_rf_rates,
Dates >= max(determine_start_dates(index_prices_local_currency)))
# To prepare for upcoming analysis: sort data frames from oldest observations (at the top) to most recent observations (at the bottom)
index_prices_local_currency <- index_prices_local_currency %>%
arrange(Dates)
CHF_FX <- CHF_FX %>%
arrange(Dates)
swiss_inflation <- swiss_inflation %>%
arrange(Dates)
CHF_rf_rates <- CHF_rf_rates %>%
arrange(Dates)
# Generate dataframe containing index prices in CHF (calculated from index_prices_local_currency and CHF_FX)
# Initialize dataframe that will contain index prices in CHF
index_prices_CHF <- index_prices_local_currency
# Select the columns representing USD, EUR, and CHF denominated indexes
usd_indexes <- c("US", "US small cap", "Europe small cap", "EM", "EM small cap", "Switzerland small cap", "World", "World small cap", "US ST treasuries 1-3Y", "US IT treasuries (3-5Y, 5-7Y, 7-10Y)", "US LT treasuries 10Y+", "EM ST treasuries 1-3Y", "EM IT treasuries (3-5Y, 5-7Y, 7-10Y)", "EM LT treasuries 10Y+", "World ST treasuries 1-3Y", "World IT treasuries (3-5Y, 5-7Y, 7-10Y)", "World LT treasuries 10Y+", "Gold bullion")
eur_indexes <- c("Europe", "Europe ST treasuries 1-3Y", "Europe IT treasuries (3-5Y, 5-7Y, 7-10Y)", "Europe LT treasuries 10Y+")
chf_indexes <- c("Switzerland", "Switzerland ST treasuries 1-3Y", "Switzerland IT treasuries (3-5Y, 5-7Y, 7-10Y)", "Switzerland LT treasuries 10Y+")
# Multiply USD denominated columns by CHF/USD exchange rate
index_prices_CHF[, usd_indexes] <- index_prices_CHF[, usd_indexes] * CHF_FX[["CHF per USD"]]
# Multiply EUR denominated columns by CHF/EUR exchange rate
index_prices_CHF[, eur_indexes] <- index_prices_CHF[, eur_indexes] * CHF_FX[["CHF per EUR"]]
# Inspect dataframe index_prices_CHF
print(index_prices_CHF)
colnames(index_prices_CHF)
head(index_prices_CHF, 10)
tail(index_prices_CHF, 10)
# Generate dataframe containing daily price returns in CHF (calculated from index_prices_CHF)
# Initialize dataframe that will contain daily price returns in CHF
index_daily_returns_CHF <- data.frame(index_prices_CHF$Dates)
names(index_daily_returns_CHF)[1] <- "Dates"
# Calculate daily price returns for each index in CHF
num_rows <- nrow(index_prices_CHF)
for (col in colnames(index_prices_CHF)[-1]) {
prices <- index_prices_CHF[[col]]
returns <- (prices[2:num_rows] / prices[1:(num_rows - 1)]) - 1
index_daily_returns_CHF[[col]] <- c(NA, returns)
}
index_daily_returns_CHF <- na.omit(index_daily_returns_CHF) # This removes the first row, which only contains returns of value NA
# Inspect the size of the cleaned data that we continue from
print(paste("index_daily_returns_CHF:", round(object.size(index_daily_returns_CHF) / 1048576, 2), "MB"))
print(paste("CHF_FX:", round(object.size(CHF_FX) / 1048576, 2), "MB"))
print(paste("CHF_rf_rates:", round(object.size(CHF_rf_rates) / 1048576, 2), "MB"))
print(paste("swiss_inflation:", round(object.size(swiss_inflation) / 1048576, 2), "MB"))
# Generate new data frames with additional investment strategies of equally-weighted indices, from our daily index returns in CHF
strategies_max_2_comb_daily_rebal <- generate_weighted_cols_daily_rebal(index_daily_returns_CHF, 2)
# [1] "Execution time:  0.358608961105347 seconds"
strategies_max_3_comb_daily_rebal <- generate_weighted_cols_daily_rebal(index_daily_returns_CHF, 3)
# [1] "Execution time:  3.06886792182922 seconds"
strategies_max_4_comb_daily_rebal <- generate_weighted_cols_daily_rebal(index_daily_returns_CHF, 4)
# Assuming 'Dates' column is in the format of "yyyy-mm-dd"
index_daily_returns_CHF$Dates <- as.Date(index_daily_returns_CHF$Dates)
xts_index_daily_returns_CHF <- xts(index_daily_returns_CHF[-1], order.by=index_daily_returns_CHF$Dates)
# Define the function that applies the formula for compound returns
compound_return <- function(x) {
prod(1 + x) - 1
}
# Define the function that aggregates returns
compound_return_multi_col  <- function(x) {
apply(x, 2, compound_return)
}
### Generate new xts objects with different investment strategies of equally-weighted indices, using our weekly/monthly/quarterly/yearly index returns in CHF
# Create aggregated time series that represent returns for yearly/quarterly/monthly/weekly rebalancing
xts_index_yearly_returns_CHF <- apply.yearly(xts_index_daily_returns_CHF, compound_return_multi_col)
xts_index_quarterly_returns_CHF <- apply.quarterly(xts_index_daily_returns_CHF, compound_return_multi_col)
xts_index_monthly_returns_CHF <- apply.monthly(xts_index_daily_returns_CHF, compound_return_multi_col)
xts_index_weekly_returns_CHF <- apply.weekly(xts_index_daily_returns_CHF, compound_return_multi_col)
## Max 2 combinations: yearly/quarterly/monthly/weekly/daily rebalancing
xts_strategies_max_2_comb_yearly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_yearly_returns_CHF,
max_comb_size = 2)
xts_strategies_max_2_comb_quarterly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_quarterly_returns_CHF,
max_comb_size = 2)
xts_strategies_max_2_comb_monthly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_monthly_returns_CHF,
max_comb_size = 2)
xts_strategies_max_2_comb_weekly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_weekly_returns_CHF,
max_comb_size = 2)
xts_strategies_max_2_comb_daily_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_daily_returns_CHF,
max_comb_size = 2)
## Max 3 combinations: yearly/quarterly/monthly/weekly/daily rebalancing
xts_strategies_max_3_comb_yearly_rebal <- xts_generate_weighted_cols(xts_return_series = xts_index_yearly_returns_CHF,
max_comb_size = 3)
# Inspect the size of the generated dataframes that contain the different investment strategies
print(paste("strategies_max_2_comb_daily_rebal (generated):", round(object.size(strategies_max_2_comb_daily_rebal) / 1048576, 2), "MB"))
# [1] "strategies_max_2_comb_daily_rebal (generated): 13.64 MB"
print(paste("strategies_max_3_comb_daily_rebal (generated):", round(object.size(strategies_max_3_comb_daily_rebal) / 1048576, 2), "MB"))
# [1] "strategies_max_3_comb_daily_rebal (generated): 114.36 MB"
print(paste("strategies_max_4_comb_daily_rebal (generated):", round(object.size(strategies_max_4_comb_daily_rebal) / 1048576, 2), "MB"))
# Inspect the size of the generated xts objects that contain the different investment strategies
print(paste("xts_strategies_max_2_comb_yearly_rebal (generated):", round(object.size(xts_strategies_max_2_comb_yearly_rebal) / 1048576, 2), "MB"))
# Plot the correlation matrix between returns of the initial 26 indices
plot_correlation_matrix(index_daily_returns_CHF)
# Plot the mean-variance graph for daily returns of each investment strategy in the data frame (first column is "Dates")
# First for only the 26 initial variables, than for all combinations up to 2, than for all higher number of combinations.
plot_mean_variance_graph(index_daily_returns_CHF)
plot_mean_variance_graph(strategies_max_2_comb_daily_rebal)
plot_mean_variance_graph(strategies_max_3_comb_daily_rebal)
plot_mean_variance_graph(strategies_max_4_comb_daily_rebal)
# Get the directory path of the current code file
PATH <- dirname(rstudioapi::getSourceEditorContext()$path)
# Set the working directory to that of the current code file
setwd(PATH)
# Load the objects from 'my_workspace.RData' into the workspace
# It's a good practice to start a new session or clear the workspace before loading the saved objects.
load('all_data_max_4_comb.RData')
# Load functions file
source("BDA_BDBD_functions - Luca.R")
# Call the function determine_optimal_strategy_v1 with specified input parameters
your_candidate_strategies_results_v1 <- determine_optimal_strategy_v1(df_return_series = index_daily_returns_CHF,
time_horizon_years = 10,
minimum_allowable_percentage = 0.85)
# Extract the results from the function output into individual variables
your_plot_lowest_returns_for_each_strategy_v1 <- your_candidate_strategies_results_v1[[1]]
your_optimal_strategy_v1 <- your_candidate_strategies_results_v1[[2]]
your_plot_optimal_strategy_v1 <- your_candidate_strategies_results_v1[[3]]
your_strategies_above_threshold_v1 <- your_candidate_strategies_results_v1[[4]]
your_strategies_below_threshold_v1 <- your_candidate_strategies_results_v1[[5]]
your_plots_for_each_strategy_v1 <- your_candidate_strategies_results_v1[[6]]
your_total_function_time_v1 <- your_candidate_strategies_results_v1[[7]]
# your_plot_lowest_returns_for_each_strategy_v1
# Plot the intermediate evolution of the lowest cumulative return series for each investment strategy (different colors for non-refused "group 1 strategies", and refused "group 2 strategies")
print(paste("Plot of the intermediate evolution of the lowest cumulative return series for each investment strategy: (see plot)"))
print(your_plot_lowest_returns_for_each_strategy_v1)
# your_optimal_strategy_v1
# Print the optimal strategy (the one strategy that delivers the best "lowest cumulative return" out of all strategies that always stayed above the threshold)
print(paste("The optimal strategy (delivers the best 'lowest cumulative return' out of all strategies that always stayed above the threshold):"))
print(your_optimal_strategy_v1)
# plot_optimal_strategy_v1
# Plot the optimal strategy's worst-case, best-case and other cumulative return series
print(paste("the optimal strategy's worst-case, best-case and other cumulative return series: (see plot)"))
print(your_plot_optimal_strategy_v1)
# your_strategies_above_threshold_v1
# Print strategies that stayed above the threshold
print(paste("Strategies that stayed above the threshold:", nrow(your_strategies_above_threshold_v1)))
print(your_strategies_above_threshold_v1)
# your_strategies_below_threshold_v1
# Print strategies that are refused for having decreased below the threshold
print(paste("Refused strategies (decreased below the threshold):", nrow(your_strategies_below_threshold_v1)))
print(your_strategies_below_threshold_v1)
# your_plots_for_each_strategy_v1
# (1) To access a specific plot from the plot list your_plots_for_each_strategy, you would index it using the strategy name as follows:
# In the place of "Strategy Name", use the exact name of the strategy you're interested in, like "US", "Europe", "World", etc.
specific_plot_v1 = your_plots_for_each_strategy_v1[["US"]]
print(specific_plot_v1)
# (2) If you would like to display multiple plots together, you can use the gridExtra package.
# You need to specify the plots you want to display as follows:
grid.arrange(
your_plots_for_each_strategy_v1[[your_optimal_strategy_v1]],
your_plots_for_each_strategy_v1[["Europe"]],
ncol = 1  # Or any other number of columns you want
)
# your_total_function_time
# Print the total execution time of the function
print(paste("Execution time for TOTAL FUNCTION: ", round(your_total_function_time_v1, 2), "seconds"))
# Define the range of years and minimum allowable percentage to compare different strategies over different time horizons and thresholds
# your_time_horizon_years <- seq(2, 12, 2)
# your_minimum_allowable_percentage <- seq(0.50, 0.90, 0.00)
your_time_horizon_years <- seq(4, 12, 4) # shorter runtime than e.g., seq(2, 12, 2)
your_minimum_allowable_percentage <- seq(0.60, 0.80, 0.20) # shorter runtime than e.g., seq(0.50, 0.90, 0.10)
# Call the function compare_results with specified input parameters
# Remark that it returns 2 objects: list(df_comparison, results_compared)
your_results_v1 <- compare_results_v1(df_return_series = index_daily_returns_CHF,
time_horizon_years = your_time_horizon_years,
minimum_allowable_percentage = your_minimum_allowable_percentage,
optimization_function = determine_optimal_strategy_v1)
df_comparison_v1 <- your_results_v1[[1]]
results_compared_v1 <- your_results_v1[[2]]
# Compare optimal strategies and total function times for different combinations of years and minimum values
print(df_comparison_v1)
# Access the results for a specific combination of years and minimum_value
# (e.g.,: 8 years; 0.50 minimum_value)
years <- 8
minimum_value <- 0.60
result_v1 <- results_compared_v1[[paste0("years_", years, "_min_", minimum_value)]]
# your_plot_lowest_returns_for_each_strategy
# Plot the intermediate evolution of the lowest cumulative return series for each investment strategy (different colors for non-refused "group 1 strategies", and refused "group 2 strategies")
print(result_v1$PlotLowestReturns)
# your_optimal_strategy
# Print the optimal strategy (the one strategy that delivers the best "lowest cumulative return" out of all strategies that always stayed above the threshold)
print(paste("The optimal strategy (delivers the best 'lowest cumulative return' out of all strategies that always stayed above the threshold):"))
print(result_v1$OptimalStrategy)
# plot_optimal_strategy
# Plot the optimal strategy's worst-case, best-case and other cumulative return series
print(result_v1$PlotOptimalStrategy)
# your_strategies_above_threshold_v1
# Print strategies that stayed above the threshold
print(paste("Strategies that stayed above the threshold:", nrow(result_v1$StrategiesAboveThreshold)))
print(result_v1$StrategiesAboveThreshold)
# your_strategies_below_threshold_v1
# Print strategies that are refused for having decreased below the threshold
print(paste("Refused strategies (decreased below the threshold):", nrow(result_v1$StrategiesBelowThreshold)))
print(result_v1$StrategiesBelowThreshold)
# your_plots_for_each_strategy
# (1) To access a specific plot from the plot list your_plots_for_each_strategy, you would index it using the strategy name as follows:
# In the place of "Strategy Name", use the exact name of the strategy you're interested in, like "US", "Europe", "World", etc.
specific_plot = result_v1$PlotsForEachStrategy[["US"]]
print(specific_plot)
# (2) If you would like to display multiple plots together, you can use the gridExtra package.
# You need to specify the plots you want to display as follows:
grid.arrange(
result_v1$PlotsForEachStrategy[[result_v1$OptimalStrategy]],
result_v1$PlotsForEachStrategy[["Europe"]],
ncol = 1  # Or any other number of columns you want
)
# your_total_function_time
# Print the total execution time of the function
print(paste("Execution time for TOTAL FUNCTION: ", round(result_v1$TotalFunctionTime, 2), "seconds"))
# Install profvis if not already installed
if (!"profvis" %in% installed.packages()) {
install.packages("profvis")
}
# Load the profvis library
library(profvis)
# Now we can run our function inside the profvis function to generate a profile
profvis({
determine_optimal_strategy_v1_timers(df_return_series = index_daily_returns_CHF,
time_horizon_years = 12,
minimum_allowable_percentage = 0.80)
})
# Run our function inside the profvis function to generate a profile, this time on a larger dataset
profvis({
determine_optimal_strategy_v1(df_return_series = strategies_max_2_comb_daily_rebal,
time_horizon_years = 5,
minimum_allowable_percentage = 0.75)
})
# Define the range of years and minimum allowable percentage to compare different strategies over different time horizons and thresholds
your_time_horizon_years <- seq(4, 12, 4)
your_minimum_allowable_percentage <- seq(0.60, 0.80, 0.20)
# Call the function compare_results with specified input parameters, for function determine_optimal_strategy_v1_timers
your_results_v1_timers <- compare_results_v1(df_return_series = index_daily_returns_CHF,
time_horizon_years = your_time_horizon_years,
minimum_allowable_percentage = your_minimum_allowable_percentage,
optimization_function = determine_optimal_strategy_v1_timers)
df_comparison_v1_timers <- your_results_v1_timers[[1]]
results_compared_v1_timers <- your_results_v1_timers[[2]]
# Compare optimal strategies and total function times for function determine_optimal_strategy_v1_timers
print(df_comparison_v1_timers)
# Call the function compare_results with specified input parameters, for function determine_optimal_strategy_vectorization_timers
your_results_vectorization_timers <- compare_results_v1(df_return_series = index_daily_returns_CHF,
time_horizon_years = your_time_horizon_years,
minimum_allowable_percentage = your_minimum_allowable_percentage,
optimization_function = determine_optimal_strategy_vectorization_timers)
df_comparison_vectorization_timers <- your_results_vectorization_timers[[1]]
results_compared_vectorization_timers <- your_results_vectorization_timers[[2]]
# Compare optimal strategies and total function times for function determine_optimal_strategy_vectorization_timers
print(df_comparison_vectorization_timers)
# Let's compare the computation time for a larger dataset (strategies_max_2_comb_daily_rebal instead of index_daily_returns_CHF)
# Define the time horizon and minimum allowable percentage
your_time_horizon_years <- seq(10, 10, 0)
your_minimum_allowable_percentage <- seq(0.75, 0.75, 0)
# Call the function compare_results with specified input parameters, for function determine_optimal_strategy_v1_timers
your_results_v1_timers <- compare_results_v1(df_return_series = strategies_max_2_comb_daily_rebal,
time_horizon_years = your_time_horizon_years,
minimum_allowable_percentage = your_minimum_allowable_percentage,
optimization_function = determine_optimal_strategy_v1_timers)
df_comparison_v1_timers <- your_results_v1_timers[[1]]
results_compared_v1_timers <- your_results_v1_timers[[2]]
# Compare optimal strategies and total function times for function determine_optimal_strategy_v1_timers
print(df_comparison_v1_timers)
# Call the function compare_results with specified input parameters, for function determine_optimal_strategy_vectorization_timers
your_results_vectorization_timers <- compare_results_v1(df_return_series = strategies_max_2_comb_daily_rebal,
time_horizon_years = your_time_horizon_years,
minimum_allowable_percentage = your_minimum_allowable_percentage,
optimization_function = determine_optimal_strategy_vectorization_timers)
df_comparison_vectorization_timers <- your_results_vectorization_timers[[1]]
results_compared_vectorization_timers <- your_results_vectorization_timers[[2]]
# Compare optimal strategies and total function times for function determine_optimal_strategy_vectorization_timers
print(df_comparison_vectorization_timers)
# df_return_series <- index_daily_returns_CHF
# df_return_series <- strategies_max_2_comb_daily_rebal
# df_return_series <- strategies_max_3_comb_daily_rebal
# df_return_series <- strategies_max_4_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
granularity = "yearly"
results_simplified_optimal_strategy <- determine_optimal_strategy_simplified(df_return_series = index_daily_returns_CHF,
time_horizon_years,
minimum_allowable_percentage,
granularity)
print(results_simplified_optimal_strategy[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_simplified_optimal_strategy[[4]], 2), "seconds"))
head(results_simplified_optimal_strategy[[2]], 3)
tail(results_simplified_optimal_strategy[[2]], 3)
head(results_simplified_optimal_strategy[[3]], 3)
tail(results_simplified_optimal_strategy[[3]], 3)
# df_return_series <- index_daily_returns_CHF
# df_return_series <- strategies_max_2_comb_daily_rebal
# df_return_series <- strategies_max_3_comb_daily_rebal
# df_return_series <- strategies_max_4_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
cutoff_percentile = 0.50
results_advanced_optimal_strategy_A <- determine_optimal_strategy_advanced_A(df_return_series = index_daily_returns_CHF,
time_horizon_years,
minimum_allowable_percentage,
cutoff_percentile = 0.50)
print(results_advanced_optimal_strategy_A[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_advanced_optimal_strategy_A[[4]], 2), "seconds"))
head(results_advanced_optimal_strategy_A[[2]], 3)
tail(results_advanced_optimal_strategy_A[[2]], 3)
head(results_advanced_optimal_strategy_A[[3]], 3)
tail(results_advanced_optimal_strategy_A[[3]], 3)
# df_return_series <- index_daily_returns_CHF
# df_return_series <- strategies_max_2_comb_daily_rebal
# df_return_series <- strategies_max_3_comb_daily_rebal
# df_return_series <- strategies_max_4_comb_daily_rebal
time_horizon_years <- 12
minimum_allowable_percentage <- 0.75
cutoff_percentile = 0.50
results_advanced_optimal_strategy_B <- determine_optimal_strategy_advanced_B(df_return_series = index_daily_returns_CHF,
time_horizon_years,
minimum_allowable_percentage,
cutoff_percentile = 0.50)
print(results_advanced_optimal_strategy_B[[1]])
print(paste("Execution time for TOTAL FUNCTION: ", round(results_advanced_optimal_strategy_B[[4]], 2), "seconds"))
head(results_advanced_optimal_strategy_B[[2]], 3)
tail(results_advanced_optimal_strategy_B[[2]], 3)
head(results_advanced_optimal_strategy_B[[3]], 3)
tail(results_advanced_optimal_strategy_B[[3]], 3)
xts_results_simplified_optimal_strategy_max_2_comb_yearly_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_2_comb_yearly_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "yearly")
# [1] "Execution time for FUNCTION xts_determine_optimal_strategy_simplified, DATASET df_return_series , GRANULARITY yearly : 2.07 seconds"
xts_results_simplified_optimal_strategy_max_2_comb_quarterly_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_2_comb_quarterly_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "quarterly")
xts_results_simplified_optimal_strategy_max_2_comb_monthly_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_2_comb_monthly_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "monthly")
# [1] "Execution time for FUNCTION xts_determine_optimal_strategy_simplified, DATASET df_return_series , GRANULARITY quarterly : 7 seconds"
xts_results_simplified_optimal_strategy_max_2_comb_weekly_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_2_comb_weekly_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "weekly")
# [1] "Execution time for FUNCTION xts_determine_optimal_strategy_simplified, DATASET df_return_series , GRANULARITY weekly : 60.61 seconds"
xts_results_simplified_optimal_strategy_max_2_comb_daily_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_2_comb_daily_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "daily")
# EXECUTION TIME ???
xts_results_simplified_optimal_strategy_max_3_comb_yearly_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_3_comb_yearly_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "yearly")
# [1] "Execution time for FUNCTION xts_determine_optimal_strategy_simplified, DATASET df_return_series , GRANULARITY yearly : 19.92 seconds"
xts_results_simplified_optimal_strategy_max_3_comb_quarterly_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_3_comb_quarterly_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "quarterly")
# EXECUTION TIME ???
xts_results_simplified_optimal_strategy_max_3_comb_monthly_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_3_comb_monthly_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "monthly")
# EXECUTION TIME ???
xts_results_simplified_optimal_strategy_max_3_comb_weekly_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_3_comb_weekly_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "weekly")
# EXECUTION TIME ???
xts_results_simplified_optimal_strategy_max_3_comb_daily_rebal <- xts_determine_optimal_strategy_simplified(xts_return_series = xts_strategies_max_3_comb_daily_rebal,
time_horizon_years = 12,
minimum_allowable_percentage = 0.75,
granularity = "daily")
calculate_returns_single_column <- function(col_name, data, period, threshold) {
# Skip Date column
if (col_name == "Date") return(NULL)
# Initialize worst period end value as infinity
worst_period_end_value <- Inf
# Initialize flag indicating whether column dropped below threshold
below_threshold <- FALSE
# Iterate over each day
for (i in 1:(nrow(data) - period + 1)) {
# Calculate product of returns for the period
period_return <- prod(1 + data[i:(i + period - 1), col_name]) * 100
# Check if period return dropped below threshold
if (period_return < threshold) {
below_threshold <- TRUE
break
}
# Update worst period end value
worst_period_end_value <- min(worst_period_end_value, period_return)
}
# If column never dropped below threshold, return result
if (!below_threshold) {
return(data.frame(Column = col_name,
Worst_Period_End_Value = worst_period_end_value,
stringsAsFactors = FALSE))
} else {
return(NULL)
}
}
calculate_returns_parallel <- function(data, years, threshold) {
# Calculate number of rows (days) per year
days_per_year <- 252  # typically there are 252 trading days in a year
# Convert years to trading days
period <- years * days_per_year
# Create cluster with number of cores
cl <- makeCluster(detectCores() - 1)
# Export necessary objects to the workers
clusterExport(cl, c("data", "period", "threshold"))
# Apply the function to each column in parallel
output <- parLapply(cl, names(data), calculate_returns_single_column)
# Stop the cluster
stopCluster(cl)
# Combine results and remove NULL results (columns that dropped below threshold)
output <- do.call("rbind", output)
# Return output
return(output)
}
# Call the function determine_optimal_strategy_v1 with specified input parameters
your_candidate_strategies_results_v1 <- determine_optimal_strategy_v1(df_return_series = index_daily_returns_CHF,
time_horizon_years = 10,
minimum_allowable_percentage = 0.85)
# Extract the results from the function output into individual variables
your_plot_lowest_returns_for_each_strategy_v1 <- your_candidate_strategies_results_v1[[1]]
your_optimal_strategy_v1 <- your_candidate_strategies_results_v1[[2]]
your_plot_optimal_strategy_v1 <- your_candidate_strategies_results_v1[[3]]
your_strategies_above_threshold_v1 <- your_candidate_strategies_results_v1[[4]]
# Call the function determine_optimal_strategy_v1 with specified input parameters
your_candidate_strategies_results_v1 <- determine_optimal_strategy_v1(df_return_series = index_daily_returns_CHF,
time_horizon_years = 10,
minimum_allowable_percentage = 0.85)
# Extract the results from the function output into individual variables
your_plot_lowest_returns_for_each_strategy_v1 <- your_candidate_strategies_results_v1[[1]]
your_optimal_strategy_v1 <- your_candidate_strategies_results_v1[[2]]
your_plot_optimal_strategy_v1 <- your_candidate_strategies_results_v1[[3]]
your_strategies_above_threshold_v1 <- your_candidate_strategies_results_v1[[4]]
your_strategies_below_threshold_v1 <- your_candidate_strategies_results_v1[[5]]
your_plots_for_each_strategy_v1 <- your_candidate_strategies_results_v1[[6]]
your_total_function_time_v1 <- your_candidate_strategies_results_v1[[7]]
# your_plot_lowest_returns_for_each_strategy_v1
# Plot the intermediate evolution of the lowest cumulative return series for each investment strategy (different colors for non-refused "group 1 strategies", and refused "group 2 strategies")
print(paste("Plot of the intermediate evolution of the lowest cumulative return series for each investment strategy: (see plot)"))
print(your_plot_lowest_returns_for_each_strategy_v1)
# your_optimal_strategy_v1
# Print the optimal strategy (the one strategy that delivers the best "lowest cumulative return" out of all strategies that always stayed above the threshold)
print(paste("The optimal strategy (delivers the best 'lowest cumulative return' out of all strategies that always stayed above the threshold):"))
print(your_optimal_strategy_v1)
# plot_optimal_strategy_v1
# Plot the optimal strategy's worst-case, best-case and other cumulative return series
print(paste("the optimal strategy's worst-case, best-case and other cumulative return series: (see plot)"))
print(your_plot_optimal_strategy_v1)
# your_strategies_above_threshold_v1
# Print strategies that stayed above the threshold
print(paste("Strategies that stayed above the threshold:", nrow(your_strategies_above_threshold_v1)))
print(your_strategies_above_threshold_v1)
# your_strategies_below_threshold_v1
# Print strategies that are refused for having decreased below the threshold
print(paste("Refused strategies (decreased below the threshold):", nrow(your_strategies_below_threshold_v1)))
print(your_strategies_below_threshold_v1)
# your_plots_for_each_strategy_v1
# (1) To access a specific plot from the plot list your_plots_for_each_strategy, you would index it using the strategy name as follows:
# In the place of "Strategy Name", use the exact name of the strategy you're interested in, like "US", "Europe", "World", etc.
specific_plot_v1 = your_plots_for_each_strategy_v1[["US"]]
print(specific_plot_v1)
# (2) If you would like to display multiple plots together, you can use the gridExtra package.
# You need to specify the plots you want to display as follows:
grid.arrange(
your_plots_for_each_strategy_v1[[your_optimal_strategy_v1]],
your_plots_for_each_strategy_v1[["Europe"]],
ncol = 1  # Or any other number of columns you want
)
# your_total_function_time
# Print the total execution time of the function
print(paste("Execution time for TOTAL FUNCTION: ", round(your_total_function_time_v1, 2), "seconds"))
# Define the range of years and minimum allowable percentage to compare different strategies over different time horizons and thresholds
# your_time_horizon_years <- seq(2, 12, 2)
# your_minimum_allowable_percentage <- seq(0.50, 0.90, 0.00)
your_time_horizon_years <- seq(4, 12, 4) # shorter runtime than e.g., seq(2, 12, 2)
your_minimum_allowable_percentage <- seq(0.60, 0.80, 0.20) # shorter runtime than e.g., seq(0.50, 0.90, 0.10)
# Call the function compare_results with specified input parameters
# Remark that it returns 2 objects: list(df_comparison, results_compared)
your_results_v1 <- compare_results_v1(df_return_series = index_daily_returns_CHF,
time_horizon_years = your_time_horizon_years,
minimum_allowable_percentage = your_minimum_allowable_percentage,
optimization_function = determine_optimal_strategy_v1)
df_comparison_v1 <- your_results_v1[[1]]
